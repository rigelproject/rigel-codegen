<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="next" href="Llvm_analysis.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Llvm" rel="Chapter" href="Llvm.html">
<link title="Llvm_analysis" rel="Chapter" href="Llvm_analysis.html">
<link title="Llvm_bitreader" rel="Chapter" href="Llvm_bitreader.html">
<link title="Llvm_bitwriter" rel="Chapter" href="Llvm_bitwriter.html">
<link title="Llvm_executionengine" rel="Chapter" href="Llvm_executionengine.html">
<link title="Llvm_scalar_opts" rel="Chapter" href="Llvm_scalar_opts.html">
<link title="Llvm_target" rel="Chapter" href="Llvm_target.html"><link title="Abstract types" rel="Section" href="#6_Abstracttypes">
<link title="Iteration" rel="Section" href="#6_Iteration">
<link title="Exceptions" rel="Section" href="#6_Exceptions">
<link title="Contexts" rel="Section" href="#6_Contexts">
<link title="Modules" rel="Section" href="#6_Modules">
<link title="Types" rel="Section" href="#6_Types">
<link title="Instruction builders" rel="Section" href="#6_Instructionbuilders">
<link title="Memory buffers" rel="Section" href="#6_Memorybuffers">
<link title="Pass Managers" rel="Section" href="#6_PassManagers">
<link title="Operations on integer types" rel="Subsection" href="#7_Operationsonintegertypes">
<link title="Operations on real types" rel="Subsection" href="#7_Operationsonrealtypes">
<link title="Operations on function types" rel="Subsection" href="#7_Operationsonfunctiontypes">
<link title="Operations on struct types" rel="Subsection" href="#7_Operationsonstructtypes">
<link title="Operations on pointer, vector, and array types" rel="Subsection" href="#7_Operationsonpointervectorandarraytypes">
<link title="Operations on other types" rel="Subsection" href="#7_Operationsonothertypes">
<link title="Operations on type handles" rel="Subsection" href="#7_Operationsontypehandles">
<link title="Operations on constants of (mostly) any type" rel="Subsection" href="#7_Operationsonconstantsofmostlyanytype">
<link title="Operations on instructions" rel="Subsection" href="#7_Operationsoninstructions">
<link title="Operations on metadata" rel="Subsection" href="#7_Operationsonmetadata">
<link title="Operations on scalar constants" rel="Subsection" href="#7_Operationsonscalarconstants">
<link title="Operations on composite constants" rel="Subsection" href="#7_Operationsoncompositeconstants">
<link title="Constant expressions" rel="Subsection" href="#7_Constantexpressions">
<link title="Operations on global variables, functions, and aliases (globals)" rel="Subsection" href="#7_Operationsonglobalvariablesfunctionsandaliasesglobals">
<link title="Operations on global variables" rel="Subsection" href="#7_Operationsonglobalvariables">
<link title="Operations on aliases" rel="Subsection" href="#7_Operationsonaliases">
<link title="Operations on functions" rel="Subsection" href="#7_Operationsonfunctions">
<link title="Operations on params" rel="Subsection" href="#7_Operationsonparams">
<link title="Operations on basic blocks" rel="Subsection" href="#7_Operationsonbasicblocks">
<link title="Operations on instructions" rel="Subsection" href="#7_Operationsoninstructions">
<link title="Operations on call sites" rel="Subsection" href="#7_Operationsoncallsites">
<link title="Operations on phi nodes" rel="Subsection" href="#7_Operationsonphinodes">
<link title="Metadata" rel="Subsection" href="#7_Metadata">
<link title="Terminators" rel="Subsection" href="#7_Terminators">
<link title="Arithmetic" rel="Subsection" href="#7_Arithmetic">
<link title="Memory" rel="Subsection" href="#7_Memory">
<link title="Casts" rel="Subsection" href="#7_Casts">
<link title="Comparisons" rel="Subsection" href="#7_Comparisons">
<link title="Miscellaneous instructions" rel="Subsection" href="#7_Miscellaneousinstructions">
<title>Llvm</title>
</head>
<body>
<div class="navbar">&nbsp;<a href="index.html">Up</a>
&nbsp;<a href="Llvm_analysis.html">Next</a>
</div>
<center><h1>Module <a href="type_Llvm.html">Llvm</a></h1></center>
<br>
<pre><span class="keyword">module</span> Llvm: <code class="code"><span class="keyword">sig</span></code> <a href="Llvm.html">..</a> <code class="code"><span class="keyword">end</span></code></pre>Core API.
<p>

    This interface provides an ocaml API for the LLVM intermediate
    representation, the classes in the VMCore library.<br>
<hr width="100%">
<br>
<a name="6_Abstracttypes"></a>
<h6>Abstract types</h6>
<p>

    These abstract types correlate directly to the LLVM VMCore classes.<br>
<pre><span class="keyword">type</span> <a name="TYPEllcontext"></a><code class="type"></code>llcontext </pre>
<div class="info">
The top-level container for all LLVM global data. See the
    <code class="code">llvm::<span class="constructor">LLVMContext</span></code> class.<br>
</div>

<pre><span class="keyword">type</span> <a name="TYPEllmodule"></a><code class="type"></code>llmodule </pre>
<div class="info">
The top-level container for all other LLVM Intermediate Representation (IR)
    objects. See the <code class="code">llvm::<span class="constructor">Module</span></code> class.<br>
</div>

<pre><span class="keyword">type</span> <a name="TYPElltype"></a><code class="type"></code>lltype </pre>
<div class="info">
Each value in the LLVM IR has a type, an instance of <code class="code">lltype</code>. See the
    <code class="code">llvm::<span class="constructor">Type</span></code> class.<br>
</div>

<pre><span class="keyword">type</span> <a name="TYPElltypehandle"></a><code class="type"></code>lltypehandle </pre>
<div class="info">
When building recursive types using <a href="Llvm.html#VALrefine_type"><code class="code"><span class="constructor">Llvm</span>.refine_type</code></a>, <code class="code">lltype</code> values may
    become invalid; use <code class="code">lltypehandle</code> to resolve this problem. See the
    <code class="code">llvm::<span class="constructor">AbstractTypeHolder</span></code> class.<br>
</div>

<pre><span class="keyword">type</span> <a name="TYPEllvalue"></a><code class="type"></code>llvalue </pre>
<div class="info">
Any value in the LLVM IR. Functions, instructions, global variables,
    constants, and much more are all <code class="code">llvalues</code>. See the <code class="code">llvm::<span class="constructor">Value</span></code> class.
    This type covers a wide range of subclasses.<br>
</div>

<pre><span class="keyword">type</span> <a name="TYPElluse"></a><code class="type"></code>lluse </pre>
<div class="info">
Used to store users and usees of values. See the <code class="code">llvm::<span class="constructor">Use</span></code> class.<br>
</div>

<pre><span class="keyword">type</span> <a name="TYPEllbasicblock"></a><code class="type"></code>llbasicblock </pre>
<div class="info">
A basic block in LLVM IR. See the <code class="code">llvm::<span class="constructor">BasicBlock</span></code> class.<br>
</div>

<pre><span class="keyword">type</span> <a name="TYPEllbuilder"></a><code class="type"></code>llbuilder </pre>
<div class="info">
Used to generate instructions in the LLVM IR. See the <code class="code">llvm::<span class="constructor">LLVMBuilder</span></code>
    class.<br>
</div>

<pre><span class="keyword">type</span> <a name="TYPEllmemorybuffer"></a><code class="type"></code>llmemorybuffer </pre>
<div class="info">
Used to efficiently handle large buffers of read-only binary data.
    See the <code class="code">llvm::<span class="constructor">MemoryBuffer</span></code> class.<br>
</div>

<pre><span class="keyword">module</span> <a href="Llvm.TypeKind.html">TypeKind</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Llvm.TypeKind.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
The kind of an <code class="code">lltype</code>, the result of <code class="code">classify_type ty</code>.
</div>
<pre><span class="keyword">module</span> <a href="Llvm.Linkage.html">Linkage</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Llvm.Linkage.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
The linkage of a global value, accessed with <a href="Llvm.html#VALlinkage"><code class="code"><span class="constructor">Llvm</span>.linkage</code></a> and
    <a href="Llvm.html#VALset_linkage"><code class="code"><span class="constructor">Llvm</span>.set_linkage</code></a>.
</div>
<pre><span class="keyword">module</span> <a href="Llvm.Visibility.html">Visibility</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Llvm.Visibility.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
The linker visibility of a global value, accessed with <a href="Llvm.html#VALvisibility"><code class="code"><span class="constructor">Llvm</span>.visibility</code></a> and
    <a href="Llvm.html#VALset_visibility"><code class="code"><span class="constructor">Llvm</span>.set_visibility</code></a>.
</div>
<pre><span class="keyword">module</span> <a href="Llvm.CallConv.html">CallConv</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Llvm.CallConv.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
The following calling convention values may be accessed with
    <a href="Llvm.html#VALfunction_call_conv"><code class="code"><span class="constructor">Llvm</span>.function_call_conv</code></a> and <a href="Llvm.html#VALset_function_call_conv"><code class="code"><span class="constructor">Llvm</span>.set_function_call_conv</code></a>.
</div>
<pre><span class="keyword">module</span> <a href="Llvm.Attribute.html">Attribute</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Llvm.Attribute.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><pre><span class="keyword">module</span> <a href="Llvm.Icmp.html">Icmp</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Llvm.Icmp.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
The predicate for an integer comparison (<code class="code">icmp</code>) instruction.
</div>
<pre><span class="keyword">module</span> <a href="Llvm.Fcmp.html">Fcmp</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Llvm.Fcmp.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
The predicate for a floating-point comparison (<code class="code">fcmp</code>) instruction.
</div>
<br>
<a name="6_Iteration"></a>
<h6>Iteration</h6><br>
<br><code><span class="keyword">type</span> <a name="TYPEllpos"></a><code class="type">('a, 'b)</code> llpos = </code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">At_end</span> <span class="keyword">of</span> <code class="type">'a</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">Before</span> <span class="keyword">of</span> <code class="type">'b</code></code></td>

</tr></table>

<div class="info">
<code class="code"><span class="constructor">Before</span> b</code> and <code class="code"><span class="constructor">At_end</span> a</code> specify positions from the start of the <code class="code"><span class="keywordsign">'</span>b</code> list
    of <code class="code">a</code>. <code class="code">llpos</code> is used to specify positions in and for forward iteration
    through the various value lists maintained by the LLVM IR.<br>
</div>

<br><code><span class="keyword">type</span> <a name="TYPEllrev_pos"></a><code class="type">('a, 'b)</code> llrev_pos = </code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">At_start</span> <span class="keyword">of</span> <code class="type">'a</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span class="constructor">After</span> <span class="keyword">of</span> <code class="type">'b</code></code></td>

</tr></table>

<div class="info">
<code class="code"><span class="constructor">After</span> b</code> and <code class="code"><span class="constructor">At_start</span> a</code> specify positions from the end of the <code class="code"><span class="keywordsign">'</span>b</code> list
    of <code class="code">a</code>. <code class="code">llrev_pos</code> is used for reverse iteration through the various value
    lists maintained by the LLVM IR.<br>
</div>

<br>
<a name="6_Exceptions"></a>
<h6>Exceptions</h6><br>
<pre><span class="keyword">exception</span> <a name="EXCEPTIONIoError"></a>IoError <span class="keyword">of</span> <code class="type">string</code></pre>
<br>
<a name="6_Contexts"></a>
<h6>Contexts</h6><br>
<pre><span class="keyword">val</span> <a name="VALcreate_context"></a>create_context : <code class="type">unit -> <a href="Llvm.html#TYPEllcontext">llcontext</a></code></pre><div class="info">
<code class="code">create_context ()</code> creates a context for storing the "global" state in
    LLVM. See the constructor <code class="code">llvm::<span class="constructor">LLVMContext</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALdispose_context"></a>dispose_context : <code class="type"><a href="Llvm.html#TYPEllcontext">llcontext</a> -> unit</code></pre><div class="info">
<code class="code">destroy_context ()</code> destroys a context. See the destructor
    <code class="code">llvm::<span class="constructor">LLVMContext</span>::~<span class="constructor">LLVMContext</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALglobal_context"></a>global_context : <code class="type">unit -> <a href="Llvm.html#TYPEllcontext">llcontext</a></code></pre><div class="info">
See the function <code class="code">llvm::getGlobalContext</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALmdkind_id"></a>mdkind_id : <code class="type"><a href="Llvm.html#TYPEllcontext">llcontext</a> -> string -> int</code></pre><div class="info">
<code class="code">mdkind_id context name</code> returns the MDKind ID that corresponds to the
    name <code class="code">name</code> in the context <code class="code">context</code>.  See the function
    <code class="code">llvm::<span class="constructor">LLVMContext</span>::getMDKindID</code>.<br>
</div>
<br>
<a name="6_Modules"></a>
<h6>Modules</h6><br>
<pre><span class="keyword">val</span> <a name="VALcreate_module"></a>create_module : <code class="type"><a href="Llvm.html#TYPEllcontext">llcontext</a> -> string -> <a href="Llvm.html#TYPEllmodule">llmodule</a></code></pre><div class="info">
<code class="code">create_module context id</code> creates a module with the supplied module ID in
    the context <code class="code">context</code>.  Modules are not garbage collected; it is mandatory
    to call <a href="Llvm.html#VALdispose_module"><code class="code"><span class="constructor">Llvm</span>.dispose_module</code></a> to free memory. See the constructor
    <code class="code">llvm::<span class="constructor">Module</span>::<span class="constructor">Module</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALdispose_module"></a>dispose_module : <code class="type"><a href="Llvm.html#TYPEllmodule">llmodule</a> -> unit</code></pre><div class="info">
<code class="code">dispose_module m</code> destroys a module <code class="code">m</code> and all of the IR objects it
    contained. All references to subordinate objects are invalidated;
    referencing them will invoke undefined behavior. See the destructor
    <code class="code">llvm::<span class="constructor">Module</span>::~<span class="constructor">Module</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALtarget_triple"></a>target_triple : <code class="type"><a href="Llvm.html#TYPEllmodule">llmodule</a> -> string</code></pre><div class="info">
<code class="code">target_triple m</code> is the target specifier for the module <code class="code">m</code>, something like
    <code class="code">i686-apple-darwin8</code>. See the method <code class="code">llvm::<span class="constructor">Module</span>::getTargetTriple</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALset_target_triple"></a>set_target_triple : <code class="type">string -> <a href="Llvm.html#TYPEllmodule">llmodule</a> -> unit</code></pre><div class="info">
<code class="code">target_triple triple m</code> changes the target specifier for the module <code class="code">m</code> to
    the string <code class="code">triple</code>. See the method <code class="code">llvm::<span class="constructor">Module</span>::setTargetTriple</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALdata_layout"></a>data_layout : <code class="type"><a href="Llvm.html#TYPEllmodule">llmodule</a> -> string</code></pre><div class="info">
<code class="code">data_layout m</code> is the data layout specifier for the module <code class="code">m</code>, something
    like <code class="code">e-p:32:32:32-i1:8:8-i8:8:8-i16:16:16-...-a0:0:64-f80:128:128</code>. See the
    method <code class="code">llvm::<span class="constructor">Module</span>::getDataLayout</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALset_data_layout"></a>set_data_layout : <code class="type">string -> <a href="Llvm.html#TYPEllmodule">llmodule</a> -> unit</code></pre><div class="info">
<code class="code">set_data_layout s m</code> changes the data layout specifier for the module <code class="code">m</code>
    to the string <code class="code">s</code>. See the method <code class="code">llvm::<span class="constructor">Module</span>::setDataLayout</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALdefine_type_name"></a>define_type_name : <code class="type">string -> <a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPEllmodule">llmodule</a> -> bool</code></pre><div class="info">
<code class="code">define_type_name name ty m</code> adds a named type to the module's symbol table.
    Returns <code class="code"><span class="keyword">true</span></code> if successful. If such a name already exists, then no entry
    is added and <code class="code"><span class="keyword">false</span></code> is returned. See the <code class="code">llvm::<span class="constructor">Module</span>::addTypeName</code>
    method.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALdelete_type_name"></a>delete_type_name : <code class="type">string -> <a href="Llvm.html#TYPEllmodule">llmodule</a> -> unit</code></pre><div class="info">
<code class="code">delete_type_name name</code> removes a type name from the module's symbol
    table.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALtype_by_name"></a>type_by_name : <code class="type"><a href="Llvm.html#TYPEllmodule">llmodule</a> -> string -> <a href="Llvm.html#TYPElltype">lltype</a> option</code></pre><div class="info">
<code class="code">type_by_name m n</code> returns the type in the module <code class="code">m</code> named <code class="code">n</code>, or <code class="code"><span class="constructor">None</span></code>
    if it does not exist. See the method <code class="code">llvm::<span class="constructor">Module</span>::getTypeByName</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALdump_module"></a>dump_module : <code class="type"><a href="Llvm.html#TYPEllmodule">llmodule</a> -> unit</code></pre><div class="info">
<code class="code">dump_module m</code> prints the .ll representation of the module <code class="code">m</code> to standard
    error. See the method <code class="code">llvm::<span class="constructor">Module</span>::dump</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALset_module_inline_asm"></a>set_module_inline_asm : <code class="type"><a href="Llvm.html#TYPEllmodule">llmodule</a> -> string -> unit</code></pre><div class="info">
<code class="code">set_module_inline_asm m asm</code> sets the inline assembler for the module. See
    the method <code class="code">llvm::<span class="constructor">Module</span>::setModuleInlineAsm</code>.<br>
</div>
<br>
<a name="6_Types"></a>
<h6>Types</h6><br>
<pre><span class="keyword">val</span> <a name="VALclassify_type"></a>classify_type : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.TypeKind.html#TYPEt">TypeKind.t</a></code></pre><div class="info">
<code class="code">classify_type ty</code> returns the <a href="Llvm.TypeKind.html#TYPEt"><code class="code"><span class="constructor">Llvm</span>.<span class="constructor">TypeKind</span>.t</code></a> corresponding to the type <code class="code">ty</code>.
    See the method <code class="code">llvm::<span class="constructor">Type</span>::getTypeID</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALtype_context"></a>type_context : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPEllcontext">llcontext</a></code></pre><div class="info">
<code class="code">type_context ty</code> returns the <a href="Llvm.html#TYPEllcontext"><code class="code"><span class="constructor">Llvm</span>.llcontext</code></a> corresponding to the type <code class="code">ty</code>.
    See the method <code class="code">llvm::<span class="constructor">Type</span>::getContext</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALstring_of_lltype"></a>string_of_lltype : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> string</code></pre><div class="info">
<code class="code">string_of_lltype ty</code> returns a string describing the type <code class="code">ty</code>.<br>
</div>
<br>
<a name="7_Operationsonintegertypes"></a>
<div class="h7">Operations on integer types</div><br>
<pre><span class="keyword">val</span> <a name="VALi1_type"></a>i1_type : <code class="type"><a href="Llvm.html#TYPEllcontext">llcontext</a> -> <a href="Llvm.html#TYPElltype">lltype</a></code></pre><div class="info">
<code class="code">i1_type c</code> returns an integer type of bitwidth 1 in the context <code class="code">c</code>. See
    <code class="code">llvm::<span class="constructor">Type</span>::<span class="constructor">Int1Ty</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALi8_type"></a>i8_type : <code class="type"><a href="Llvm.html#TYPEllcontext">llcontext</a> -> <a href="Llvm.html#TYPElltype">lltype</a></code></pre><div class="info">
<code class="code">i8_type c</code> returns an integer type of bitwidth 8 in the context <code class="code">c</code>. See
    <code class="code">llvm::<span class="constructor">Type</span>::<span class="constructor">Int8Ty</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALi16_type"></a>i16_type : <code class="type"><a href="Llvm.html#TYPEllcontext">llcontext</a> -> <a href="Llvm.html#TYPElltype">lltype</a></code></pre><div class="info">
<code class="code">i16_type c</code> returns an integer type of bitwidth 16 in the context <code class="code">c</code>. See
    <code class="code">llvm::<span class="constructor">Type</span>::<span class="constructor">Int16Ty</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALi32_type"></a>i32_type : <code class="type"><a href="Llvm.html#TYPEllcontext">llcontext</a> -> <a href="Llvm.html#TYPElltype">lltype</a></code></pre><div class="info">
<code class="code">i32_type c</code> returns an integer type of bitwidth 32 in the context <code class="code">c</code>. See
    <code class="code">llvm::<span class="constructor">Type</span>::<span class="constructor">Int32Ty</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALi64_type"></a>i64_type : <code class="type"><a href="Llvm.html#TYPEllcontext">llcontext</a> -> <a href="Llvm.html#TYPElltype">lltype</a></code></pre><div class="info">
<code class="code">i64_type c</code> returns an integer type of bitwidth 64 in the context <code class="code">c</code>. See
    <code class="code">llvm::<span class="constructor">Type</span>::<span class="constructor">Int64Ty</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALinteger_type"></a>integer_type : <code class="type"><a href="Llvm.html#TYPEllcontext">llcontext</a> -> int -> <a href="Llvm.html#TYPElltype">lltype</a></code></pre><div class="info">
<code class="code">integer_type c n</code> returns an integer type of bitwidth <code class="code">n</code> in the context
    <code class="code">c</code>. See the method <code class="code">llvm::<span class="constructor">IntegerType</span>::get</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALinteger_bitwidth"></a>integer_bitwidth : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> int</code></pre><div class="info">
<code class="code">integer_bitwidth c ty</code> returns the number of bits in the integer type <code class="code">ty</code>
    in the context <code class="code">c</code>.  See the method <code class="code">llvm::<span class="constructor">IntegerType</span>::getBitWidth</code>.<br>
</div>
<br>
<a name="7_Operationsonrealtypes"></a>
<div class="h7">Operations on real types</div><br>
<pre><span class="keyword">val</span> <a name="VALfloat_type"></a>float_type : <code class="type"><a href="Llvm.html#TYPEllcontext">llcontext</a> -> <a href="Llvm.html#TYPElltype">lltype</a></code></pre><div class="info">
<code class="code">float_type c</code> returns the IEEE 32-bit floating point type in the context
    <code class="code">c</code>. See <code class="code">llvm::<span class="constructor">Type</span>::<span class="constructor">FloatTy</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALdouble_type"></a>double_type : <code class="type"><a href="Llvm.html#TYPEllcontext">llcontext</a> -> <a href="Llvm.html#TYPElltype">lltype</a></code></pre><div class="info">
<code class="code">double_type c</code> returns the IEEE 64-bit floating point type in the context
    <code class="code">c</code>. See <code class="code">llvm::<span class="constructor">Type</span>::<span class="constructor">DoubleTy</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALx86fp80_type"></a>x86fp80_type : <code class="type"><a href="Llvm.html#TYPEllcontext">llcontext</a> -> <a href="Llvm.html#TYPElltype">lltype</a></code></pre><div class="info">
<code class="code">x86fp80_type c</code> returns the x87 80-bit floating point type in the context
    <code class="code">c</code>. See <code class="code">llvm::<span class="constructor">Type</span>::<span class="constructor">X86_FP80Ty</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfp128_type"></a>fp128_type : <code class="type"><a href="Llvm.html#TYPEllcontext">llcontext</a> -> <a href="Llvm.html#TYPElltype">lltype</a></code></pre><div class="info">
<code class="code">fp128_type c</code> returns the IEEE 128-bit floating point type in the context
    <code class="code">c</code>. See <code class="code">llvm::<span class="constructor">Type</span>::<span class="constructor">FP128Ty</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALppc_fp128_type"></a>ppc_fp128_type : <code class="type"><a href="Llvm.html#TYPEllcontext">llcontext</a> -> <a href="Llvm.html#TYPElltype">lltype</a></code></pre><div class="info">
<code class="code">ppc_fp128_type c</code> returns the PowerPC 128-bit floating point type in the
    context <code class="code">c</code>. See <code class="code">llvm::<span class="constructor">Type</span>::<span class="constructor">PPC_FP128Ty</span></code>.<br>
</div>
<br>
<a name="7_Operationsonfunctiontypes"></a>
<div class="h7">Operations on function types</div><br>
<pre><span class="keyword">val</span> <a name="VALfunction_type"></a>function_type : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPElltype">lltype</a> array -> <a href="Llvm.html#TYPElltype">lltype</a></code></pre><div class="info">
<code class="code">function_type ret_ty param_tys</code> returns the function type returning
    <code class="code">ret_ty</code> and taking <code class="code">param_tys</code> as parameters.
    See the method <code class="code">llvm::<span class="constructor">FunctionType</span>::get</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALvar_arg_function_type"></a>var_arg_function_type : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPElltype">lltype</a> array -> <a href="Llvm.html#TYPElltype">lltype</a></code></pre><div class="info">
<code class="code">va_arg_function_type ret_ty param_tys</code> is just like
    <code class="code">function_type ret_ty param_tys</code> except that it returns the function type
    which also takes a variable number of arguments.
    See the method <code class="code">llvm::<span class="constructor">FunctionType</span>::get</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALis_var_arg"></a>is_var_arg : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> bool</code></pre><div class="info">
<code class="code">is_var_arg fty</code> returns <code class="code"><span class="keyword">true</span></code> if <code class="code">fty</code> is a varargs function type, <code class="code"><span class="keyword">false</span></code>
    otherwise. See the method <code class="code">llvm::<span class="constructor">FunctionType</span>::isVarArg</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALreturn_type"></a>return_type : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPElltype">lltype</a></code></pre><div class="info">
<code class="code">return_type fty</code> gets the return type of the function type <code class="code">fty</code>.
    See the method <code class="code">llvm::<span class="constructor">FunctionType</span>::getReturnType</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALparam_types"></a>param_types : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPElltype">lltype</a> array</code></pre><div class="info">
<code class="code">param_types fty</code> gets the parameter types of the function type <code class="code">fty</code>.
    See the method <code class="code">llvm::<span class="constructor">FunctionType</span>::getParamType</code>.<br>
</div>
<br>
<a name="7_Operationsonstructtypes"></a>
<div class="h7">Operations on struct types</div><br>
<pre><span class="keyword">val</span> <a name="VALstruct_type"></a>struct_type : <code class="type"><a href="Llvm.html#TYPEllcontext">llcontext</a> -> <a href="Llvm.html#TYPElltype">lltype</a> array -> <a href="Llvm.html#TYPElltype">lltype</a></code></pre><div class="info">
<code class="code">struct_type context tys</code> returns the structure type in the context
    <code class="code">context</code> containing in the types in the array <code class="code">tys</code>. See the method
    <code class="code">llvm::<span class="constructor">StructType</span>::get</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALpacked_struct_type"></a>packed_struct_type : <code class="type"><a href="Llvm.html#TYPEllcontext">llcontext</a> -> <a href="Llvm.html#TYPElltype">lltype</a> array -> <a href="Llvm.html#TYPElltype">lltype</a></code></pre><div class="info">
<code class="code">packed_struct_type context ys</code> returns the packed structure type in the
    context <code class="code">context</code> containing in the types in the array <code class="code">tys</code>. See the method
    <code class="code">llvm::<span class="constructor">StructType</span>::get</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALstruct_element_types"></a>struct_element_types : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPElltype">lltype</a> array</code></pre><div class="info">
<code class="code">struct_element_types sty</code> returns the constituent types of the struct type
    <code class="code">sty</code>. See the method <code class="code">llvm::<span class="constructor">StructType</span>::getElementType</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALis_packed"></a>is_packed : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> bool</code></pre><div class="info">
<code class="code">is_packed sty</code> returns <code class="code"><span class="keyword">true</span></code> if the structure type <code class="code">sty</code> is packed,
    <code class="code"><span class="keyword">false</span></code> otherwise. See the method <code class="code">llvm::<span class="constructor">StructType</span>::isPacked</code>.<br>
</div>
<br>
<a name="7_Operationsonpointervectorandarraytypes"></a>
<div class="h7">Operations on pointer, vector, and array types</div><br>
<pre><span class="keyword">val</span> <a name="VALarray_type"></a>array_type : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> int -> <a href="Llvm.html#TYPElltype">lltype</a></code></pre><div class="info">
<code class="code">array_type ty n</code> returns the array type containing <code class="code">n</code> elements of type
    <code class="code">ty</code>. See the method <code class="code">llvm::<span class="constructor">ArrayType</span>::get</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALpointer_type"></a>pointer_type : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPElltype">lltype</a></code></pre><div class="info">
<code class="code">pointer_type ty</code> returns the pointer type referencing objects of type
    <code class="code">ty</code> in the default address space (0).
    See the method <code class="code">llvm::<span class="constructor">PointerType</span>::getUnqual</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALqualified_pointer_type"></a>qualified_pointer_type : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> int -> <a href="Llvm.html#TYPElltype">lltype</a></code></pre><div class="info">
<code class="code">qualified_pointer_type ty <span class="keyword">as</span></code> returns the pointer type referencing objects
    of type <code class="code">ty</code> in address space <code class="code"><span class="keyword">as</span></code>.
    See the method <code class="code">llvm::<span class="constructor">PointerType</span>::get</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALvector_type"></a>vector_type : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> int -> <a href="Llvm.html#TYPElltype">lltype</a></code></pre><div class="info">
<code class="code">vector_type ty n</code> returns the array type containing <code class="code">n</code> elements of the
    primitive type <code class="code">ty</code>. See the method <code class="code">llvm::<span class="constructor">ArrayType</span>::get</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALelement_type"></a>element_type : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPElltype">lltype</a></code></pre><div class="info">
<code class="code">element_type ty</code> returns the element type of the pointer, vector, or array
    type <code class="code">ty</code>. See the method <code class="code">llvm::<span class="constructor">SequentialType</span>::get</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALarray_length"></a>array_length : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> int</code></pre><div class="info">
<code class="code">element_type aty</code> returns the element count of the array type <code class="code">aty</code>.
    See the method <code class="code">llvm::<span class="constructor">ArrayType</span>::getNumElements</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALaddress_space"></a>address_space : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> int</code></pre><div class="info">
<code class="code">address_space pty</code> returns the address space qualifier of the pointer type
    <code class="code">pty</code>. See the method <code class="code">llvm::<span class="constructor">PointerType</span>::getAddressSpace</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALvector_size"></a>vector_size : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> int</code></pre><div class="info">
<code class="code">element_type ty</code> returns the element count of the vector type <code class="code">ty</code>.
    See the method <code class="code">llvm::<span class="constructor">VectorType</span>::getNumElements</code>.<br>
</div>
<br>
<a name="7_Operationsonothertypes"></a>
<div class="h7">Operations on other types</div><br>
<pre><span class="keyword">val</span> <a name="VALopaque_type"></a>opaque_type : <code class="type"><a href="Llvm.html#TYPEllcontext">llcontext</a> -> <a href="Llvm.html#TYPElltype">lltype</a></code></pre><div class="info">
<code class="code">opaque_type c</code> creates a new opaque type distinct from any other in the
    context <code class="code">c</code>. Opaque types are useful for building recursive types in
    combination with <a href="Llvm.html#VALrefine_type"><code class="code"><span class="constructor">Llvm</span>.refine_type</code></a>. See <code class="code">llvm::<span class="constructor">OpaqueType</span>::get</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALvoid_type"></a>void_type : <code class="type"><a href="Llvm.html#TYPEllcontext">llcontext</a> -> <a href="Llvm.html#TYPElltype">lltype</a></code></pre><div class="info">
<code class="code">void_type c</code> creates a type of a function which does not return any
    value in the context <code class="code">c</code>. See <code class="code">llvm::<span class="constructor">Type</span>::<span class="constructor">VoidTy</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALlabel_type"></a>label_type : <code class="type"><a href="Llvm.html#TYPEllcontext">llcontext</a> -> <a href="Llvm.html#TYPElltype">lltype</a></code></pre><div class="info">
<code class="code">label_type c</code> creates a type of a basic block in the context <code class="code">c</code>. See
    <code class="code">llvm::<span class="constructor">Type</span>::<span class="constructor">LabelTy</span></code>.<br>
</div>
<br>
<a name="7_Operationsontypehandles"></a>
<div class="h7">Operations on type handles</div><br>
<pre><span class="keyword">val</span> <a name="VALhandle_to_type"></a>handle_to_type : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPElltypehandle">lltypehandle</a></code></pre><div class="info">
<code class="code">handle_to_type ty</code> creates a handle to the type <code class="code">ty</code>. If <code class="code">ty</code> is later
    refined as a result of a call to <a href="Llvm.html#VALrefine_type"><code class="code"><span class="constructor">Llvm</span>.refine_type</code></a>, the handle will be updated;
    any bare <code class="code">lltype</code> references will become invalid.
    See the class <code class="code">llvm::<span class="constructor">PATypeHolder</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALtype_of_handle"></a>type_of_handle : <code class="type"><a href="Llvm.html#TYPElltypehandle">lltypehandle</a> -> <a href="Llvm.html#TYPElltype">lltype</a></code></pre><div class="info">
<code class="code">type_of_handle tyh</code> resolves the type handle <code class="code">tyh</code>.
    See the method <code class="code">llvm::<span class="constructor">PATypeHolder</span>::get()</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALrefine_type"></a>refine_type : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> unit</code></pre><div class="info">
<code class="code">refine_type opaque_ty ty</code> replaces the abstract type <code class="code">opaque_ty</code> with the
    concrete type <code class="code">ty</code> in all users. Warning: This may invalidate <a href="Llvm.html#TYPElltype"><code class="code"><span class="constructor">Llvm</span>.lltype</code></a>
    values! Use <a href="Llvm.html#TYPElltypehandle"><code class="code"><span class="constructor">Llvm</span>.lltypehandle</code></a> to manipulate potentially abstract types. See
    the method <code class="code">llvm::<span class="constructor">Type</span>::refineAbstractType</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALtype_of"></a>type_of : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a></code></pre><div class="info">
<code class="code">type_of v</code> returns the type of the value <code class="code">v</code>.
    See the method <code class="code">llvm::<span class="constructor">Value</span>::getType</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALvalue_name"></a>value_name : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> string</code></pre><div class="info">
<code class="code">value_name v</code> returns the name of the value <code class="code">v</code>. For global values, this is
    the symbol name. For instructions and basic blocks, it is the SSA register
    name. It is meaningless for constants.
    See the method <code class="code">llvm::<span class="constructor">Value</span>::getName</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALset_value_name"></a>set_value_name : <code class="type">string -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> unit</code></pre><div class="info">
<code class="code">set_value_name n v</code> sets the name of the value <code class="code">v</code> to <code class="code">n</code>. See the method
    <code class="code">llvm::<span class="constructor">Value</span>::setName</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALdump_value"></a>dump_value : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> unit</code></pre><div class="info">
<code class="code">dump_value v</code> prints the .ll representation of the value <code class="code">v</code> to standard
    error. See the method <code class="code">llvm::<span class="constructor">Value</span>::dump</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALreplace_all_uses_with"></a>replace_all_uses_with : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> unit</code></pre><div class="info">
<code class="code">replace_all_uses_with old <span class="keyword">new</span></code> replaces all uses of the value <code class="code">old</code>
 * with the value <code class="code"><span class="keyword">new</span></code>. See the method <code class="code">llvm::<span class="constructor">Value</span>::replaceAllUsesWith</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALuse_begin"></a>use_begin : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElluse">lluse</a> option</code></pre><div class="info">
<code class="code">use_begin v</code> returns the first position in the use list for the value <code class="code">v</code>.
    <code class="code">use_begin</code> and <code class="code">use_succ</code> can e used to iterate over the use list in order.
    See the method <code class="code">llvm::<span class="constructor">Value</span>::use_begin</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALuse_succ"></a>use_succ : <code class="type"><a href="Llvm.html#TYPElluse">lluse</a> -> <a href="Llvm.html#TYPElluse">lluse</a> option</code></pre><div class="info">
<code class="code">use_succ u</code> returns the use list position succeeding <code class="code">u</code>.
    See the method <code class="code">llvm::use_value_iterator::operator++</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALuser"></a>user : <code class="type"><a href="Llvm.html#TYPElluse">lluse</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">user u</code> returns the user of the use <code class="code">u</code>.
    See the method <code class="code">llvm::<span class="constructor">Use</span>::getUser</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALused_value"></a>used_value : <code class="type"><a href="Llvm.html#TYPElluse">lluse</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">used_value u</code> returns the usee of the use <code class="code">u</code>.
    See the method <code class="code">llvm::<span class="constructor">Use</span>::getUsedValue</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALiter_uses"></a>iter_uses : <code class="type">(<a href="Llvm.html#TYPElluse">lluse</a> -> unit) -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> unit</code></pre><div class="info">
<code class="code">iter_uses f v</code> applies function <code class="code">f</code> to each of the users of the value <code class="code">v</code>
    in order. Tail recursive.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfold_left_uses"></a>fold_left_uses : <code class="type">('a -> <a href="Llvm.html#TYPElluse">lluse</a> -> 'a) -> 'a -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> 'a</code></pre><div class="info">
<code class="code">fold_left_uses f init v</code> is <code class="code">f (... (f init u1) ...) uN</code> where
    <code class="code">u1,...,uN</code> are the users of the value <code class="code">v</code>. Tail recursive.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfold_right_uses"></a>fold_right_uses : <code class="type">(<a href="Llvm.html#TYPElluse">lluse</a> -> 'a -> 'a) -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> 'a -> 'a</code></pre><div class="info">
<code class="code">fold_right_uses f v init</code> is <code class="code">f u1 (... (f uN init) ...)</code> where
    <code class="code">u1,...,uN</code> are the users of the value <code class="code">v</code>. Not tail recursive.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALoperand"></a>operand : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> int -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">operand v i</code> returns the operand at index <code class="code">i</code> for the value <code class="code">v</code>. See the
    method <code class="code">llvm::<span class="constructor">User</span>::getOperand</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALset_operand"></a>set_operand : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> int -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> unit</code></pre><div class="info">
<code class="code">set_operand v i o</code> sets the operand of the value <code class="code">v</code> at the index <code class="code">i</code> to
    the value <code class="code">o</code>.
    See the method <code class="code">llvm::<span class="constructor">User</span>::setOperand</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALnum_operands"></a>num_operands : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> int</code></pre><div class="info">
<code class="code">num_operands v</code> returns the number of operands for the value <code class="code">v</code>.
    See the method <code class="code">llvm::<span class="constructor">User</span>::getNumOperands</code>.<br>
</div>
<br>
<a name="7_Operationsonconstantsofmostlyanytype"></a>
<div class="h7">Operations on constants of (mostly) any type</div><br>
<pre><span class="keyword">val</span> <a name="VALis_constant"></a>is_constant : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> bool</code></pre><div class="info">
<code class="code">is_constant v</code> returns <code class="code"><span class="keyword">true</span></code> if the value <code class="code">v</code> is a constant, <code class="code"><span class="keyword">false</span></code>
    otherwise. Similar to <code class="code">llvm::isa&lt;<span class="constructor">Constant</span>&gt;</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_null"></a>const_null : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_null ty</code> returns the constant null (zero) of the type <code class="code">ty</code>.
    See the method <code class="code">llvm::<span class="constructor">Constant</span>::getNullValue</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_all_ones"></a>const_all_ones : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_all_ones ty</code> returns the constant '-1' of the integer or vector type
    <code class="code">ty</code>. See the method <code class="code">llvm::<span class="constructor">Constant</span>::getAllOnesValue</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_pointer_null"></a>const_pointer_null : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_pointer_null ty</code> returns the constant null (zero) pointer of the type
    <code class="code">ty</code>. See the method <code class="code">llvm::<span class="constructor">ConstantPointerNull</span>::get</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALundef"></a>undef : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">undef ty</code> returns the undefined value of the type <code class="code">ty</code>.
    See the method <code class="code">llvm::<span class="constructor">UndefValue</span>::get</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALis_null"></a>is_null : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> bool</code></pre><div class="info">
<code class="code">is_null v</code> returns <code class="code"><span class="keyword">true</span></code> if the value <code class="code">v</code> is the null (zero) value.
    See the method <code class="code">llvm::<span class="constructor">Constant</span>::isNullValue</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALis_undef"></a>is_undef : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> bool</code></pre><div class="info">
<code class="code">is_undef v</code> returns <code class="code"><span class="keyword">true</span></code> if the value <code class="code">v</code> is an undefined value, <code class="code"><span class="keyword">false</span></code>
    otherwise. Similar to <code class="code">llvm::isa&lt;<span class="constructor">UndefValue</span>&gt;</code>.<br>
</div>
<br>
<a name="7_Operationsoninstructions"></a>
<div class="h7">Operations on instructions</div><br>
<pre><span class="keyword">val</span> <a name="VALhas_metadata"></a>has_metadata : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> bool</code></pre><div class="info">
<code class="code">has_metadata i</code> returns whether or not the instruction <code class="code">i</code> has any
    metadata attached to it. See the function
    <code class="code">llvm::<span class="constructor">Instruction</span>::hasMetadata</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALmetadata"></a>metadata : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> int -> <a href="Llvm.html#TYPEllvalue">llvalue</a> option</code></pre><div class="info">
<code class="code">metadata i kind</code> optionally returns the metadata associated with the
    kind <code class="code">kind</code> in the instruction <code class="code">i</code> See the function
    <code class="code">llvm::<span class="constructor">Instruction</span>::getMetadata</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALset_metadata"></a>set_metadata : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> int -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> unit</code></pre><div class="info">
<code class="code">set_metadata i kind md</code> sets the metadata <code class="code">md</code> of kind <code class="code">kind</code> in the
    instruction <code class="code">i</code>. See the function <code class="code">llvm::<span class="constructor">Instruction</span>::setMetadata</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALclear_metadata"></a>clear_metadata : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> int -> unit</code></pre><div class="info">
<code class="code">clear_metadata i kind</code> clears the metadata of kind <code class="code">kind</code> in the
    instruction <code class="code">i</code>. See the function <code class="code">llvm::<span class="constructor">Instruction</span>::setMetadata</code>.<br>
</div>
<br>
<a name="7_Operationsonmetadata"></a>
<div class="h7">Operations on metadata</div><br>
<pre><span class="keyword">val</span> <a name="VALmdstring"></a>mdstring : <code class="type"><a href="Llvm.html#TYPEllcontext">llcontext</a> -> string -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">mdstring c s</code> returns the MDString of the string <code class="code">s</code> in the context <code class="code">c</code>.
    See the method <code class="code">llvm::<span class="constructor">MDNode</span>::get</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALmdnode"></a>mdnode : <code class="type"><a href="Llvm.html#TYPEllcontext">llcontext</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> array -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">mdnode c elts</code> returns the MDNode containing the values <code class="code">elts</code> in the
    context <code class="code">c</code>.
    See the method <code class="code">llvm::<span class="constructor">MDNode</span>::get</code>.<br>
</div>
<br>
<a name="7_Operationsonscalarconstants"></a>
<div class="h7">Operations on scalar constants</div><br>
<pre><span class="keyword">val</span> <a name="VALconst_int"></a>const_int : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> int -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_int ty i</code> returns the integer constant of type <code class="code">ty</code> and value <code class="code">i</code>.
    See the method <code class="code">llvm::<span class="constructor">ConstantInt</span>::get</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_of_int64"></a>const_of_int64 : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> Int64.t -> bool -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_of_int64 ty i</code> returns the integer constant of type <code class="code">ty</code> and value
    <code class="code">i</code>. See the method <code class="code">llvm::<span class="constructor">ConstantInt</span>::get</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_int_of_string"></a>const_int_of_string : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> string -> int -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_int_of_string ty s r</code> returns the integer constant of type <code class="code">ty</code> and
 * value <code class="code">s</code>, with the radix <code class="code">r</code>. See the method <code class="code">llvm::<span class="constructor">ConstantInt</span>::get</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_float"></a>const_float : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> float -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_float ty n</code> returns the floating point constant of type <code class="code">ty</code> and
    value <code class="code">n</code>. See the method <code class="code">llvm::<span class="constructor">ConstantFP</span>::get</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_float_of_string"></a>const_float_of_string : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> string -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_float_of_string ty s</code> returns the floating point constant of type
    <code class="code">ty</code> and value <code class="code">n</code>. See the method <code class="code">llvm::<span class="constructor">ConstantFP</span>::get</code>.<br>
</div>
<br>
<a name="7_Operationsoncompositeconstants"></a>
<div class="h7">Operations on composite constants</div><br>
<pre><span class="keyword">val</span> <a name="VALconst_string"></a>const_string : <code class="type"><a href="Llvm.html#TYPEllcontext">llcontext</a> -> string -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_string c s</code> returns the constant <code class="code">i8</code> array with the values of the
    characters in the string <code class="code">s</code> in the context <code class="code">c</code>. The array is not 
    null-terminated (but see <a href="Llvm.html#VALconst_stringz"><code class="code"><span class="constructor">Llvm</span>.const_stringz</code></a>). This value can in turn be used
    as the initializer for a global variable. See the method
    <code class="code">llvm::<span class="constructor">ConstantArray</span>::get</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_stringz"></a>const_stringz : <code class="type"><a href="Llvm.html#TYPEllcontext">llcontext</a> -> string -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_stringz c s</code> returns the constant <code class="code">i8</code> array with the values of the
    characters in the string <code class="code">s</code> and a null terminator in the context <code class="code">c</code>. This
    value can in turn be used as the initializer for a global variable.
    See the method <code class="code">llvm::<span class="constructor">ConstantArray</span>::get</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_array"></a>const_array : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> array -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_array ty elts</code> returns the constant array of type
    <code class="code">array_type ty (<span class="constructor">Array</span>.length elts)</code> and containing the values <code class="code">elts</code>.
    This value can in turn be used as the initializer for a global variable.
    See the method <code class="code">llvm::<span class="constructor">ConstantArray</span>::get</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_struct"></a>const_struct : <code class="type"><a href="Llvm.html#TYPEllcontext">llcontext</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> array -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_struct context elts</code> returns the structured constant of type
    <code class="code">struct_type (<span class="constructor">Array</span>.map type_of elts)</code> and containing the values <code class="code">elts</code>
    in the context <code class="code">context</code>. This value can in turn be used as the initializer
    for a global variable. See the method <code class="code">llvm::<span class="constructor">ConstantStruct</span>::get</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_packed_struct"></a>const_packed_struct : <code class="type"><a href="Llvm.html#TYPEllcontext">llcontext</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> array -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_packed_struct context elts</code> returns the structured constant of
    type <a href="Llvm.html#VALpacked_struct_type"><code class="code"><span class="constructor">Llvm</span>.packed_struct_type</code></a> <code class="code">(<span class="constructor">Array</span>.map type_of elts)</code> and containing the
    values <code class="code">elts</code> in the context <code class="code">context</code>. This value can in turn be used as
    the initializer for a global variable. See the method
    <code class="code">llvm::<span class="constructor">ConstantStruct</span>::get</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_vector"></a>const_vector : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> array -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_vector elts</code> returns the vector constant of type
    <code class="code">vector_type (type_of elts.(0)) (<span class="constructor">Array</span>.length elts)</code> and containing the
    values <code class="code">elts</code>. See the method <code class="code">llvm::<span class="constructor">ConstantVector</span>::get</code>.<br>
</div>
<br>
<a name="7_Constantexpressions"></a>
<div class="h7">Constant expressions</div><br>
<pre><span class="keyword">val</span> <a name="VALalign_of"></a>align_of : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">align_of ty</code> returns the alignof constant for the type <code class="code">ty</code>. This is
    equivalent to <code class="code">const_ptrtoint (const_gep (const_null (pointer_type {i8,ty}))
    (const_int i32_type 0) (const_int i32_type 1)) i32_type</code>, but considerably
    more readable.  See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getAlignOf</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALsize_of"></a>size_of : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">size_of ty</code> returns the sizeof constant for the type <code class="code">ty</code>. This is
    equivalent to <code class="code">const_ptrtoint (const_gep (const_null (pointer_type ty))
    (const_int i32_type 1)) i64_type</code>, but considerably more readable.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getSizeOf</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_neg"></a>const_neg : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_neg c</code> returns the arithmetic negation of the constant <code class="code">c</code>.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getNeg</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_nsw_neg"></a>const_nsw_neg : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_nsw_neg c</code> returns the arithmetic negation of the constant <code class="code">c</code> with
    no signed wrapping. The result is undefined if the negation overflows.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getNSWNeg</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_nuw_neg"></a>const_nuw_neg : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_nuw_neg c</code> returns the arithmetic negation of the constant <code class="code">c</code> with
    no unsigned wrapping. The result is undefined if the negation overflows.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getNUWNeg</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_fneg"></a>const_fneg : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_fneg c</code> returns the arithmetic negation of the constant float <code class="code">c</code>.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getFNeg</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_not"></a>const_not : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_not c</code> returns the bitwise inverse of the constant <code class="code">c</code>.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getNot</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_add"></a>const_add : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_add c1 c2</code> returns the constant sum of two constants.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getAdd</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_nsw_add"></a>const_nsw_add : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_nsw_add c1 c2</code> returns the constant sum of two constants with no
    signed wrapping. The result is undefined if the sum overflows.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getNSWAdd</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_nuw_add"></a>const_nuw_add : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_nuw_add c1 c2</code> returns the constant sum of two constants with no
    unsigned wrapping. The result is undefined if the sum overflows.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getNSWAdd</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_fadd"></a>const_fadd : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_fadd c1 c2</code> returns the constant sum of two constant floats.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getFAdd</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_sub"></a>const_sub : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_sub c1 c2</code> returns the constant difference, <code class="code">c1 - c2</code>, of two
    constants. See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getSub</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_nsw_sub"></a>const_nsw_sub : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_nsw_sub c1 c2</code> returns the constant difference of two constants with
    no signed wrapping. The result is undefined if the sum overflows.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getNSWSub</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_nuw_sub"></a>const_nuw_sub : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_nuw_sub c1 c2</code> returns the constant difference of two constants with
    no unsigned wrapping. The result is undefined if the sum overflows.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getNSWSub</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_fsub"></a>const_fsub : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_fsub c1 c2</code> returns the constant difference, <code class="code">c1 - c2</code>, of two
    constant floats. See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getFSub</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_mul"></a>const_mul : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_mul c1 c2</code> returns the constant product of two constants.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getMul</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_nsw_mul"></a>const_nsw_mul : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_nsw_mul c1 c2</code> returns the constant product of two constants with
    no signed wrapping. The result is undefined if the sum overflows.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getNSWMul</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_nuw_mul"></a>const_nuw_mul : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_nuw_mul c1 c2</code> returns the constant product of two constants with
    no unsigned wrapping. The result is undefined if the sum overflows.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getNSWMul</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_fmul"></a>const_fmul : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_fmul c1 c2</code> returns the constant product of two constants floats.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getFMul</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_udiv"></a>const_udiv : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_udiv c1 c2</code> returns the constant quotient <code class="code">c1 / c2</code> of two unsigned
    integer constants.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getUDiv</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_sdiv"></a>const_sdiv : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_sdiv c1 c2</code> returns the constant quotient <code class="code">c1 / c2</code> of two signed
    integer constants.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getSDiv</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_exact_sdiv"></a>const_exact_sdiv : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_exact_sdiv c1 c2</code> returns the constant quotient <code class="code">c1 / c2</code> of two
    signed integer constants. The result is undefined if the result is rounded
    or overflows. See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getExactSDiv</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_fdiv"></a>const_fdiv : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_fdiv c1 c2</code> returns the constant quotient <code class="code">c1 / c2</code> of two floating
    point constants.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getFDiv</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_urem"></a>const_urem : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_urem c1 c2</code> returns the constant remainder <code class="code">c1 <span class="constructor">MOD</span> c2</code> of two
    unsigned integer constants.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getURem</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_srem"></a>const_srem : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_srem c1 c2</code> returns the constant remainder <code class="code">c1 <span class="constructor">MOD</span> c2</code> of two
    signed integer constants.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getSRem</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_frem"></a>const_frem : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_frem c1 c2</code> returns the constant remainder <code class="code">c1 <span class="constructor">MOD</span> c2</code> of two
    signed floating point constants.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getFRem</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_and"></a>const_and : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_and c1 c2</code> returns the constant bitwise <code class="code"><span class="constructor">AND</span></code> of two integer
    constants.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getAnd</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_or"></a>const_or : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_or c1 c2</code> returns the constant bitwise <code class="code"><span class="constructor">OR</span></code> of two integer
    constants.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getOr</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_xor"></a>const_xor : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_xor c1 c2</code> returns the constant bitwise <code class="code"><span class="constructor">XOR</span></code> of two integer
    constants.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getXor</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_icmp"></a>const_icmp : <code class="type"><a href="Llvm.Icmp.html#TYPEt">Icmp.t</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_icmp pred c1 c2</code> returns the constant comparison of two integer
    constants, <code class="code">c1 pred c2</code>.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getICmp</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_fcmp"></a>const_fcmp : <code class="type"><a href="Llvm.Fcmp.html#TYPEt">Fcmp.t</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_fcmp pred c1 c2</code> returns the constant comparison of two floating
    point constants, <code class="code">c1 pred c2</code>.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getFCmp</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_shl"></a>const_shl : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_shl c1 c2</code> returns the constant integer <code class="code">c1</code> left-shifted by the
    constant integer <code class="code">c2</code>.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getShl</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_lshr"></a>const_lshr : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_lshr c1 c2</code> returns the constant integer <code class="code">c1</code> right-shifted by the
    constant integer <code class="code">c2</code> with zero extension.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getLShr</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_ashr"></a>const_ashr : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_ashr c1 c2</code> returns the constant integer <code class="code">c1</code> right-shifted by the
    constant integer <code class="code">c2</code> with sign extension.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getAShr</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_gep"></a>const_gep : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> array -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_gep pc indices</code> returns the constant <code class="code">getElementPtr</code> of <code class="code">p1</code> with the
    constant integers indices from the array <code class="code">indices</code>.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getGetElementPtr</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_in_bounds_gep"></a>const_in_bounds_gep : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> array -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_in_bounds_gep pc indices</code> returns the constant <code class="code">getElementPtr</code> of <code class="code">p1</code>
    with the constant integers indices from the array <code class="code">indices</code>.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getInBoundsGetElementPtr</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_trunc"></a>const_trunc : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_trunc c ty</code> returns the constant truncation of integer constant <code class="code">c</code>
    to the smaller integer type <code class="code">ty</code>.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getTrunc</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_sext"></a>const_sext : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_sext c ty</code> returns the constant sign extension of integer constant
    <code class="code">c</code> to the larger integer type <code class="code">ty</code>.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getSExt</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_zext"></a>const_zext : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_zext c ty</code> returns the constant zero extension of integer constant
    <code class="code">c</code> to the larger integer type <code class="code">ty</code>.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getZExt</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_fptrunc"></a>const_fptrunc : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_fptrunc c ty</code> returns the constant truncation of floating point
    constant <code class="code">c</code> to the smaller floating point type <code class="code">ty</code>.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getFPTrunc</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_fpext"></a>const_fpext : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_fpext c ty</code> returns the constant extension of floating point constant
    <code class="code">c</code> to the larger floating point type <code class="code">ty</code>.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getFPExt</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_uitofp"></a>const_uitofp : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_uitofp c ty</code> returns the constant floating point conversion of
    unsigned integer constant <code class="code">c</code> to the floating point type <code class="code">ty</code>.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getUIToFP</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_sitofp"></a>const_sitofp : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_sitofp c ty</code> returns the constant floating point conversion of
    signed integer constant <code class="code">c</code> to the floating point type <code class="code">ty</code>.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getSIToFP</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_fptoui"></a>const_fptoui : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_fptoui c ty</code> returns the constant unsigned integer conversion of
    floating point constant <code class="code">c</code> to integer type <code class="code">ty</code>.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getFPToUI</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_fptosi"></a>const_fptosi : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_fptoui c ty</code> returns the constant unsigned integer conversion of
    floating point constant <code class="code">c</code> to integer type <code class="code">ty</code>.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getFPToSI</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_ptrtoint"></a>const_ptrtoint : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_ptrtoint c ty</code> returns the constant integer conversion of
    pointer constant <code class="code">c</code> to integer type <code class="code">ty</code>.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getPtrToInt</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_inttoptr"></a>const_inttoptr : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_inttoptr c ty</code> returns the constant pointer conversion of
    integer constant <code class="code">c</code> to pointer type <code class="code">ty</code>.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getIntToPtr</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_bitcast"></a>const_bitcast : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_bitcast c ty</code> returns the constant bitwise conversion of constant <code class="code">c</code>
    to type <code class="code">ty</code> of equal size.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getBitCast</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_zext_or_bitcast"></a>const_zext_or_bitcast : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_zext_or_bitcast c ty</code> returns a constant zext or bitwise cast
    conversion of constant <code class="code">c</code> to type <code class="code">ty</code>.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getZExtOrBitCast</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_sext_or_bitcast"></a>const_sext_or_bitcast : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_sext_or_bitcast c ty</code> returns a constant sext or bitwise cast
    conversion of constant <code class="code">c</code> to type <code class="code">ty</code>.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getSExtOrBitCast</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_trunc_or_bitcast"></a>const_trunc_or_bitcast : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_trunc_or_bitcast c ty</code> returns a constant trunc or bitwise cast
    conversion of constant <code class="code">c</code> to type <code class="code">ty</code>.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getTruncOrBitCast</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_pointercast"></a>const_pointercast : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_pointercast c ty</code> returns a constant bitcast or a pointer-to-int
    cast conversion of constant <code class="code">c</code> to type <code class="code">ty</code> of equal size.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getPointerCast</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_intcast"></a>const_intcast : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_intcast c ty</code> returns a constant zext, bitcast, or trunc for integer
    -&gt; integer casts of constant <code class="code">c</code> to type <code class="code">ty</code>.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getIntCast</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_fpcast"></a>const_fpcast : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_fpcast c ty</code> returns a constant fpext, bitcast, or fptrunc for fp -&gt;
    fp casts of constant <code class="code">c</code> to type <code class="code">ty</code>.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getFPCast</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_select"></a>const_select : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_select cond t f</code> returns the constant conditional which returns value
    <code class="code">t</code> if the boolean constant <code class="code">cond</code> is true and the value <code class="code">f</code> otherwise.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getSelect</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_extractelement"></a>const_extractelement : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_extractelement vec i</code> returns the constant <code class="code">i</code>th element of
    constant vector <code class="code">vec</code>. <code class="code">i</code> must be a constant <code class="code">i32</code> value unsigned less than
    the size of the vector.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getExtractElement</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_insertelement"></a>const_insertelement : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_insertelement vec v i</code> returns the constant vector with the same
    elements as constant vector <code class="code">v</code> but the <code class="code">i</code>th element replaced by the
    constant <code class="code">v</code>. <code class="code">v</code> must be a constant value with the type of the vector
    elements. <code class="code">i</code> must be a constant <code class="code">i32</code> value unsigned less than the size
    of the vector.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getInsertElement</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_shufflevector"></a>const_shufflevector : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_shufflevector a b mask</code> returns a constant <code class="code">shufflevector</code>.
    See the LLVM Language Reference for details on the <code class="code">shufflevector</code>
    instruction.
    See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getShuffleVector</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_extractvalue"></a>const_extractvalue : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> int array -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_extractvalue agg idxs</code> returns the constant <code class="code">idxs</code>th value of
    constant aggregate <code class="code">agg</code>. Each <code class="code">idxs</code> must be less than the size of the
    aggregate.  See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getExtractValue</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_insertvalue"></a>const_insertvalue : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> int array -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_insertvalue agg <span class="keyword">val</span> idxs</code> inserts the value <code class="code"><span class="keyword">val</span></code> in the specified
    indexs <code class="code">idxs</code> in the aggegate <code class="code">agg</code>. Each <code class="code">idxs</code> must be less than the size
    of the aggregate. See the method <code class="code">llvm::<span class="constructor">ConstantExpr</span>::getInsertValue</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALconst_inline_asm"></a>const_inline_asm : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> string -> string -> bool -> bool -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">const_inline_asm ty asm con side align</code> inserts a inline assembly string.
    See the method <code class="code">llvm::<span class="constructor">InlineAsm</span>::get</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALblock_address"></a>block_address : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllbasicblock">llbasicblock</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">block_address f bb</code> returns the address of the basic block <code class="code">bb</code> in the
    function <code class="code">f</code>. See the method <code class="code">llvm::<span class="constructor">BasicBlock</span>::get</code>.<br>
</div>
<br>
<a name="7_Operationsonglobalvariablesfunctionsandaliasesglobals"></a>
<div class="h7">Operations on global variables, functions, and aliases (globals)</div><br>
<pre><span class="keyword">val</span> <a name="VALglobal_parent"></a>global_parent : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllmodule">llmodule</a></code></pre><div class="info">
<code class="code">global_parent g</code> is the enclosing module of the global value <code class="code">g</code>.
    See the method <code class="code">llvm::<span class="constructor">GlobalValue</span>::getParent</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALis_declaration"></a>is_declaration : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> bool</code></pre><div class="info">
<code class="code">is_declaration g</code> returns <code class="code"><span class="keyword">true</span></code> if the global value <code class="code">g</code> is a declaration
    only. Returns <code class="code"><span class="keyword">false</span></code> otherwise.
    See the method <code class="code">llvm::<span class="constructor">GlobalValue</span>::isDeclaration</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALlinkage"></a>linkage : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.Linkage.html#TYPEt">Linkage.t</a></code></pre><div class="info">
<code class="code">linkage g</code> returns the linkage of the global value <code class="code">g</code>.
    See the method <code class="code">llvm::<span class="constructor">GlobalValue</span>::getLinkage</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALset_linkage"></a>set_linkage : <code class="type"><a href="Llvm.Linkage.html#TYPEt">Linkage.t</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> unit</code></pre><div class="info">
<code class="code">set_linkage l g</code> sets the linkage of the global value <code class="code">g</code> to <code class="code">l</code>.
    See the method <code class="code">llvm::<span class="constructor">GlobalValue</span>::setLinkage</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALsection"></a>section : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> string</code></pre><div class="info">
<code class="code">section g</code> returns the linker section of the global value <code class="code">g</code>.
    See the method <code class="code">llvm::<span class="constructor">GlobalValue</span>::getSection</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALset_section"></a>set_section : <code class="type">string -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> unit</code></pre><div class="info">
<code class="code">set_section s g</code> sets the linker section of the global value <code class="code">g</code> to <code class="code">s</code>.
    See the method <code class="code">llvm::<span class="constructor">GlobalValue</span>::setSection</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALvisibility"></a>visibility : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.Visibility.html#TYPEt">Visibility.t</a></code></pre><div class="info">
<code class="code">visibility g</code> returns the linker visibility of the global value <code class="code">g</code>.
    See the method <code class="code">llvm::<span class="constructor">GlobalValue</span>::getVisibility</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALset_visibility"></a>set_visibility : <code class="type"><a href="Llvm.Visibility.html#TYPEt">Visibility.t</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> unit</code></pre><div class="info">
<code class="code">set_visibility v g</code> sets the linker visibility of the global value <code class="code">g</code> to
    <code class="code">v</code>. See the method <code class="code">llvm::<span class="constructor">GlobalValue</span>::setVisibility</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALalignment"></a>alignment : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> int</code></pre><div class="info">
<code class="code">alignment g</code> returns the required alignment of the global value <code class="code">g</code>.
    See the method <code class="code">llvm::<span class="constructor">GlobalValue</span>::getAlignment</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALset_alignment"></a>set_alignment : <code class="type">int -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> unit</code></pre><div class="info">
<code class="code">set_alignment n g</code> sets the required alignment of the global value <code class="code">g</code> to
    <code class="code">n</code> bytes. See the method <code class="code">llvm::<span class="constructor">GlobalValue</span>::setAlignment</code>.<br>
</div>
<br>
<a name="7_Operationsonglobalvariables"></a>
<div class="h7">Operations on global variables</div><br>
<pre><span class="keyword">val</span> <a name="VALdeclare_global"></a>declare_global : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> string -> <a href="Llvm.html#TYPEllmodule">llmodule</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">declare_global ty name m</code> returns a new global variable of type <code class="code">ty</code> and
    with name <code class="code">name</code> in module <code class="code">m</code> in the default address space (0). If such a
    global variable already exists, it is returned. If the type of the existing
    global differs, then a bitcast to <code class="code">ty</code> is returned.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALdeclare_qualified_global"></a>declare_qualified_global : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> string -> int -> <a href="Llvm.html#TYPEllmodule">llmodule</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">declare_qualified_global ty name addrspace m</code> returns a new global variable
    of type <code class="code">ty</code> and with name <code class="code">name</code> in module <code class="code">m</code> in the address space
    <code class="code">addrspace</code>. If such a global variable already exists, it is returned. If
    the type of the existing global differs, then a bitcast to <code class="code">ty</code> is
    returned.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALdefine_global"></a>define_global : <code class="type">string -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllmodule">llmodule</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">define_global name init m</code> returns a new global with name <code class="code">name</code> and
    initializer <code class="code">init</code> in module <code class="code">m</code> in the default address space (0). If the
    named global already exists, it is renamed.
    See the constructor of <code class="code">llvm::<span class="constructor">GlobalVariable</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALdefine_qualified_global"></a>define_qualified_global : <code class="type">string -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> int -> <a href="Llvm.html#TYPEllmodule">llmodule</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">define_qualified_global name init addrspace m</code> returns a new global with
    name <code class="code">name</code> and initializer <code class="code">init</code> in module <code class="code">m</code> in the address space
    <code class="code">addrspace</code>. If the named global already exists, it is renamed.
    See the constructor of <code class="code">llvm::<span class="constructor">GlobalVariable</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALlookup_global"></a>lookup_global : <code class="type">string -> <a href="Llvm.html#TYPEllmodule">llmodule</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> option</code></pre><div class="info">
<code class="code">lookup_global name m</code> returns <code class="code"><span class="constructor">Some</span> g</code> if a global variable with name
    <code class="code">name</code> exists in module <code class="code">m</code>. If no such global exists, returns <code class="code"><span class="constructor">None</span></code>.
    See the <code class="code">llvm::<span class="constructor">GlobalVariable</span></code> constructor.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALdelete_global"></a>delete_global : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> unit</code></pre><div class="info">
<code class="code">delete_global gv</code> destroys the global variable <code class="code">gv</code>.
    See the method <code class="code">llvm::<span class="constructor">GlobalVariable</span>::eraseFromParent</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALglobal_begin"></a>global_begin : <code class="type"><a href="Llvm.html#TYPEllmodule">llmodule</a> -> (<a href="Llvm.html#TYPEllmodule">llmodule</a>, <a href="Llvm.html#TYPEllvalue">llvalue</a>) <a href="Llvm.html#TYPEllpos">llpos</a></code></pre><div class="info">
<code class="code">global_begin m</code> returns the first position in the global variable list of
    the module <code class="code">m</code>. <code class="code">global_begin</code> and <code class="code">global_succ</code> can be used to iterate
    over the global list in order.
    See the method <code class="code">llvm::<span class="constructor">Module</span>::global_begin</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALglobal_succ"></a>global_succ : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> (<a href="Llvm.html#TYPEllmodule">llmodule</a>, <a href="Llvm.html#TYPEllvalue">llvalue</a>) <a href="Llvm.html#TYPEllpos">llpos</a></code></pre><div class="info">
<code class="code">global_succ gv</code> returns the global variable list position succeeding
    <code class="code"><span class="constructor">Before</span> gv</code>.
    See the method <code class="code">llvm::<span class="constructor">Module</span>::global_iterator::operator++</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALiter_globals"></a>iter_globals : <code class="type">(<a href="Llvm.html#TYPEllvalue">llvalue</a> -> unit) -> <a href="Llvm.html#TYPEllmodule">llmodule</a> -> unit</code></pre><div class="info">
<code class="code">iter_globals f m</code> applies function <code class="code">f</code> to each of the global variables of
    module <code class="code">m</code> in order. Tail recursive.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfold_left_globals"></a>fold_left_globals : <code class="type">('a -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> 'a) -> 'a -> <a href="Llvm.html#TYPEllmodule">llmodule</a> -> 'a</code></pre><div class="info">
<code class="code">fold_left_globals f init m</code> is <code class="code">f (... (f init g1) ...) gN</code> where
    <code class="code">g1,...,gN</code> are the global variables of module <code class="code">m</code>. Tail recursive.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALglobal_end"></a>global_end : <code class="type"><a href="Llvm.html#TYPEllmodule">llmodule</a> -> (<a href="Llvm.html#TYPEllmodule">llmodule</a>, <a href="Llvm.html#TYPEllvalue">llvalue</a>) <a href="Llvm.html#TYPEllrev_pos">llrev_pos</a></code></pre><div class="info">
<code class="code">global_end m</code> returns the last position in the global variable list of the
    module <code class="code">m</code>. <code class="code">global_end</code> and <code class="code">global_pred</code> can be used to iterate over the
    global list in reverse.
    See the method <code class="code">llvm::<span class="constructor">Module</span>::global_end</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALglobal_pred"></a>global_pred : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> (<a href="Llvm.html#TYPEllmodule">llmodule</a>, <a href="Llvm.html#TYPEllvalue">llvalue</a>) <a href="Llvm.html#TYPEllrev_pos">llrev_pos</a></code></pre><div class="info">
<code class="code">global_pred gv</code> returns the global variable list position preceding
    <code class="code"><span class="constructor">After</span> gv</code>.
    See the method <code class="code">llvm::<span class="constructor">Module</span>::global_iterator::operator--</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALrev_iter_globals"></a>rev_iter_globals : <code class="type">(<a href="Llvm.html#TYPEllvalue">llvalue</a> -> unit) -> <a href="Llvm.html#TYPEllmodule">llmodule</a> -> unit</code></pre><div class="info">
<code class="code">rev_iter_globals f m</code> applies function <code class="code">f</code> to each of the global variables
    of module <code class="code">m</code> in reverse order. Tail recursive.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfold_right_globals"></a>fold_right_globals : <code class="type">(<a href="Llvm.html#TYPEllvalue">llvalue</a> -> 'a -> 'a) -> <a href="Llvm.html#TYPEllmodule">llmodule</a> -> 'a -> 'a</code></pre><div class="info">
<code class="code">fold_right_globals f m init</code> is <code class="code">f g1 (... (f gN init) ...)</code> where
    <code class="code">g1,...,gN</code> are the global variables of module <code class="code">m</code>. Tail recursive.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALis_global_constant"></a>is_global_constant : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> bool</code></pre><div class="info">
<code class="code">is_global_constant gv</code> returns <code class="code"><span class="keyword">true</span></code> if the global variabile <code class="code">gv</code> is a
    constant. Returns <code class="code"><span class="keyword">false</span></code> otherwise.
    See the method <code class="code">llvm::<span class="constructor">GlobalVariable</span>::isConstant</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALset_global_constant"></a>set_global_constant : <code class="type">bool -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> unit</code></pre><div class="info">
<code class="code">set_global_constant c gv</code> sets the global variable <code class="code">gv</code> to be a constant if
    <code class="code">c</code> is <code class="code"><span class="keyword">true</span></code> and not if <code class="code">c</code> is <code class="code"><span class="keyword">false</span></code>.
    See the method <code class="code">llvm::<span class="constructor">GlobalVariable</span>::setConstant</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALglobal_initializer"></a>global_initializer : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">global_initializer gv</code> returns the initializer for the global variable
    <code class="code">gv</code>. See the method <code class="code">llvm::<span class="constructor">GlobalVariable</span>::getInitializer</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALset_initializer"></a>set_initializer : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> unit</code></pre><div class="info">
<code class="code">set_initializer c gv</code> sets the initializer for the global variable
    <code class="code">gv</code> to the constant <code class="code">c</code>.
    See the method <code class="code">llvm::<span class="constructor">GlobalVariable</span>::setInitializer</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALremove_initializer"></a>remove_initializer : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> unit</code></pre><div class="info">
<code class="code">remove_initializer gv</code> unsets the initializer for the global variable
    <code class="code">gv</code>.
    See the method <code class="code">llvm::<span class="constructor">GlobalVariable</span>::setInitializer</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALis_thread_local"></a>is_thread_local : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> bool</code></pre><div class="info">
<code class="code">is_thread_local gv</code> returns <code class="code"><span class="keyword">true</span></code> if the global variable <code class="code">gv</code> is
    thread-local and <code class="code"><span class="keyword">false</span></code> otherwise.
    See the method <code class="code">llvm::<span class="constructor">GlobalVariable</span>::isThreadLocal</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALset_thread_local"></a>set_thread_local : <code class="type">bool -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> unit</code></pre><div class="info">
<code class="code">set_thread_local c gv</code> sets the global variable <code class="code">gv</code> to be thread local if
    <code class="code">c</code> is <code class="code"><span class="keyword">true</span></code> and not otherwise.
    See the method <code class="code">llvm::<span class="constructor">GlobalVariable</span>::setThreadLocal</code>.<br>
</div>
<br>
<a name="7_Operationsonaliases"></a>
<div class="h7">Operations on aliases</div><br>
<pre><span class="keyword">val</span> <a name="VALadd_alias"></a>add_alias : <code class="type"><a href="Llvm.html#TYPEllmodule">llmodule</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">add_alias m t a n</code> inserts an alias in the module <code class="code">m</code> with the type <code class="code">t</code> and
    the aliasee <code class="code">a</code> with the name <code class="code">n</code>.
    See the constructor for <code class="code">llvm::<span class="constructor">GlobalAlias</span></code>.<br>
</div>
<br>
<a name="7_Operationsonfunctions"></a>
<div class="h7">Operations on functions</div><br>
<pre><span class="keyword">val</span> <a name="VALdeclare_function"></a>declare_function : <code class="type">string -> <a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPEllmodule">llmodule</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">declare_function name ty m</code> returns a new function of type <code class="code">ty</code> and
    with name <code class="code">name</code> in module <code class="code">m</code>. If such a function already exists,
    it is returned. If the type of the existing function differs, then a bitcast
    to <code class="code">ty</code> is returned.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALdefine_function"></a>define_function : <code class="type">string -> <a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPEllmodule">llmodule</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">define_function name ty m</code> creates a new function with name <code class="code">name</code> and
    type <code class="code">ty</code> in module <code class="code">m</code>. If the named function already exists, it is
    renamed. An entry basic block is created in the function.
    See the constructor of <code class="code">llvm::<span class="constructor">GlobalVariable</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALlookup_function"></a>lookup_function : <code class="type">string -> <a href="Llvm.html#TYPEllmodule">llmodule</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> option</code></pre><div class="info">
<code class="code">lookup_function name m</code> returns <code class="code"><span class="constructor">Some</span> f</code> if a function with name
    <code class="code">name</code> exists in module <code class="code">m</code>. If no such function exists, returns <code class="code"><span class="constructor">None</span></code>.
    See the method <code class="code">llvm::<span class="constructor">Module</span></code> constructor.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALdelete_function"></a>delete_function : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> unit</code></pre><div class="info">
<code class="code">delete_function f</code> destroys the function <code class="code">f</code>.
    See the method <code class="code">llvm::<span class="constructor">Function</span>::eraseFromParent</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfunction_begin"></a>function_begin : <code class="type"><a href="Llvm.html#TYPEllmodule">llmodule</a> -> (<a href="Llvm.html#TYPEllmodule">llmodule</a>, <a href="Llvm.html#TYPEllvalue">llvalue</a>) <a href="Llvm.html#TYPEllpos">llpos</a></code></pre><div class="info">
<code class="code">function_begin m</code> returns the first position in the function list of the
    module <code class="code">m</code>. <code class="code">function_begin</code> and <code class="code">function_succ</code> can be used to iterate over
    the function list in order.
    See the method <code class="code">llvm::<span class="constructor">Module</span>::<span class="keyword">begin</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfunction_succ"></a>function_succ : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> (<a href="Llvm.html#TYPEllmodule">llmodule</a>, <a href="Llvm.html#TYPEllvalue">llvalue</a>) <a href="Llvm.html#TYPEllpos">llpos</a></code></pre><div class="info">
<code class="code">function_succ gv</code> returns the function list position succeeding
    <code class="code"><span class="constructor">Before</span> gv</code>.
    See the method <code class="code">llvm::<span class="constructor">Module</span>::iterator::operator++</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALiter_functions"></a>iter_functions : <code class="type">(<a href="Llvm.html#TYPEllvalue">llvalue</a> -> unit) -> <a href="Llvm.html#TYPEllmodule">llmodule</a> -> unit</code></pre><div class="info">
<code class="code">iter_functions f m</code> applies function <code class="code">f</code> to each of the functions of module
    <code class="code">m</code> in order. Tail recursive.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfold_left_functions"></a>fold_left_functions : <code class="type">('a -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> 'a) -> 'a -> <a href="Llvm.html#TYPEllmodule">llmodule</a> -> 'a</code></pre><div class="info">
<code class="code">fold_left_function f init m</code> is <code class="code">f (... (f init f1) ...) fN</code> where
    <code class="code">f1,...,fN</code> are the functions of module <code class="code">m</code>. Tail recursive.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfunction_end"></a>function_end : <code class="type"><a href="Llvm.html#TYPEllmodule">llmodule</a> -> (<a href="Llvm.html#TYPEllmodule">llmodule</a>, <a href="Llvm.html#TYPEllvalue">llvalue</a>) <a href="Llvm.html#TYPEllrev_pos">llrev_pos</a></code></pre><div class="info">
<code class="code">function_end m</code> returns the last position in the function list of
    the module <code class="code">m</code>. <code class="code">function_end</code> and <code class="code">function_pred</code> can be used to iterate
    over the function list in reverse.
    See the method <code class="code">llvm::<span class="constructor">Module</span>::<span class="keyword">end</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfunction_pred"></a>function_pred : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> (<a href="Llvm.html#TYPEllmodule">llmodule</a>, <a href="Llvm.html#TYPEllvalue">llvalue</a>) <a href="Llvm.html#TYPEllrev_pos">llrev_pos</a></code></pre><div class="info">
<code class="code">function_pred gv</code> returns the function list position preceding <code class="code"><span class="constructor">After</span> gv</code>.
    See the method <code class="code">llvm::<span class="constructor">Module</span>::iterator::operator--</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALrev_iter_functions"></a>rev_iter_functions : <code class="type">(<a href="Llvm.html#TYPEllvalue">llvalue</a> -> unit) -> <a href="Llvm.html#TYPEllmodule">llmodule</a> -> unit</code></pre><div class="info">
<code class="code">rev_iter_functions f fn</code> applies function <code class="code">f</code> to each of the functions of
    module <code class="code">m</code> in reverse order. Tail recursive.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfold_right_functions"></a>fold_right_functions : <code class="type">(<a href="Llvm.html#TYPEllvalue">llvalue</a> -> 'a -> 'a) -> <a href="Llvm.html#TYPEllmodule">llmodule</a> -> 'a -> 'a</code></pre><div class="info">
<code class="code">fold_right_functions f m init</code> is <code class="code">f (... (f init fN) ...) f1</code> where
    <code class="code">f1,...,fN</code> are the functions of module <code class="code">m</code>. Tail recursive.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALis_intrinsic"></a>is_intrinsic : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> bool</code></pre><div class="info">
<code class="code">is_intrinsic f</code> returns true if the function <code class="code">f</code> is an intrinsic.
    See the method <code class="code">llvm::<span class="constructor">Function</span>::isIntrinsic</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfunction_call_conv"></a>function_call_conv : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> int</code></pre><div class="info">
<code class="code">function_call_conv f</code> returns the calling convention of the function <code class="code">f</code>.
    See the method <code class="code">llvm::<span class="constructor">Function</span>::getCallingConv</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALset_function_call_conv"></a>set_function_call_conv : <code class="type">int -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> unit</code></pre><div class="info">
<code class="code">set_function_call_conv cc f</code> sets the calling convention of the function
    <code class="code">f</code> to the calling convention numbered <code class="code">cc</code>.
    See the method <code class="code">llvm::<span class="constructor">Function</span>::setCallingConv</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALgc"></a>gc : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> string option</code></pre><div class="info">
<code class="code">gc f</code> returns <code class="code"><span class="constructor">Some</span> name</code> if the function <code class="code">f</code> has a garbage
    collection algorithm specified and <code class="code"><span class="constructor">None</span></code> otherwise.
    See the method <code class="code">llvm::<span class="constructor">Function</span>::getGC</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALset_gc"></a>set_gc : <code class="type">string option -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> unit</code></pre><div class="info">
<code class="code">set_gc gc f</code> sets the collection algorithm for the function <code class="code">f</code> to
    <code class="code">gc</code>. See the method <code class="code">llvm::<span class="constructor">Function</span>::setGC</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALadd_function_attr"></a>add_function_attr : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.Attribute.html#TYPEt">Attribute.t</a> -> unit</code></pre><div class="info">
<code class="code">add_function_attr f a</code> adds attribute <code class="code">a</code> to the return type of function
    <code class="code">f</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALremove_function_attr"></a>remove_function_attr : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.Attribute.html#TYPEt">Attribute.t</a> -> unit</code></pre><div class="info">
<code class="code">remove_function_attr f a</code> removes attribute <code class="code">a</code> from the return type of
    function <code class="code">f</code>.<br>
</div>
<br>
<a name="7_Operationsonparams"></a>
<div class="h7">Operations on params</div><br>
<pre><span class="keyword">val</span> <a name="VALparams"></a>params : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> array</code></pre><div class="info">
<code class="code">params f</code> returns the parameters of function <code class="code">f</code>.
    See the method <code class="code">llvm::<span class="constructor">Function</span>::getArgumentList</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALparam"></a>param : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> int -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">param f n</code> returns the <code class="code">n</code>th parameter of function <code class="code">f</code>.
    See the method <code class="code">llvm::<span class="constructor">Function</span>::getArgumentList</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALparam_parent"></a>param_parent : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">param_parent p</code> returns the parent function that owns the parameter.
    See the method <code class="code">llvm::<span class="constructor">Argument</span>::getParent</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALparam_begin"></a>param_begin : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> (<a href="Llvm.html#TYPEllvalue">llvalue</a>, <a href="Llvm.html#TYPEllvalue">llvalue</a>) <a href="Llvm.html#TYPEllpos">llpos</a></code></pre><div class="info">
<code class="code">param_begin f</code> returns the first position in the parameter list of the
    function <code class="code">f</code>. <code class="code">param_begin</code> and <code class="code">param_succ</code> can be used to iterate over
    the parameter list in order.
    See the method <code class="code">llvm::<span class="constructor">Function</span>::arg_begin</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALparam_succ"></a>param_succ : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> (<a href="Llvm.html#TYPEllvalue">llvalue</a>, <a href="Llvm.html#TYPEllvalue">llvalue</a>) <a href="Llvm.html#TYPEllpos">llpos</a></code></pre><div class="info">
<code class="code">param_succ bb</code> returns the parameter list position succeeding
    <code class="code"><span class="constructor">Before</span> bb</code>.
    See the method <code class="code">llvm::<span class="constructor">Function</span>::arg_iterator::operator++</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALiter_params"></a>iter_params : <code class="type">(<a href="Llvm.html#TYPEllvalue">llvalue</a> -> unit) -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> unit</code></pre><div class="info">
<code class="code">iter_params f fn</code> applies function <code class="code">f</code> to each of the parameters
    of function <code class="code">fn</code> in order. Tail recursive.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfold_left_params"></a>fold_left_params : <code class="type">('a -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> 'a) -> 'a -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> 'a</code></pre><div class="info">
<code class="code">fold_left_params f init fn</code> is <code class="code">f (... (f init b1) ...) bN</code> where
    <code class="code">b1,...,bN</code> are the parameters of function <code class="code">fn</code>. Tail recursive.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALparam_end"></a>param_end : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> (<a href="Llvm.html#TYPEllvalue">llvalue</a>, <a href="Llvm.html#TYPEllvalue">llvalue</a>) <a href="Llvm.html#TYPEllrev_pos">llrev_pos</a></code></pre><div class="info">
<code class="code">param_end f</code> returns the last position in the parameter list of
    the function <code class="code">f</code>. <code class="code">param_end</code> and <code class="code">param_pred</code> can be used to iterate
    over the parameter list in reverse.
    See the method <code class="code">llvm::<span class="constructor">Function</span>::arg_end</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALparam_pred"></a>param_pred : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> (<a href="Llvm.html#TYPEllvalue">llvalue</a>, <a href="Llvm.html#TYPEllvalue">llvalue</a>) <a href="Llvm.html#TYPEllrev_pos">llrev_pos</a></code></pre><div class="info">
<code class="code">param_pred gv</code> returns the function list position preceding <code class="code"><span class="constructor">After</span> gv</code>.
    See the method <code class="code">llvm::<span class="constructor">Function</span>::arg_iterator::operator--</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALrev_iter_params"></a>rev_iter_params : <code class="type">(<a href="Llvm.html#TYPEllvalue">llvalue</a> -> unit) -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> unit</code></pre><div class="info">
<code class="code">rev_iter_params f fn</code> applies function <code class="code">f</code> to each of the parameters
    of function <code class="code">fn</code> in reverse order. Tail recursive.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfold_right_params"></a>fold_right_params : <code class="type">(<a href="Llvm.html#TYPEllvalue">llvalue</a> -> 'a -> 'a) -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> 'a -> 'a</code></pre><div class="info">
<code class="code">fold_right_params f fn init</code> is <code class="code">f (... (f init bN) ...) b1</code> where
    <code class="code">b1,...,bN</code> are the parameters of function <code class="code">fn</code>. Tail recursive.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALadd_param_attr"></a>add_param_attr : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.Attribute.html#TYPEt">Attribute.t</a> -> unit</code></pre><div class="info">
<code class="code">add_param p a</code> adds attribute <code class="code">a</code> to parameter <code class="code">p</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALremove_param_attr"></a>remove_param_attr : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.Attribute.html#TYPEt">Attribute.t</a> -> unit</code></pre><div class="info">
<code class="code">remove_param_attr p a</code> removes attribute <code class="code">a</code> from parameter <code class="code">p</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALset_param_alignment"></a>set_param_alignment : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> int -> unit</code></pre><div class="info">
<code class="code">set_param_alignment p a</code> set the alignment of parameter <code class="code">p</code> to <code class="code">a</code>.<br>
</div>
<br>
<a name="7_Operationsonbasicblocks"></a>
<div class="h7">Operations on basic blocks</div><br>
<pre><span class="keyword">val</span> <a name="VALbasic_blocks"></a>basic_blocks : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllbasicblock">llbasicblock</a> array</code></pre><div class="info">
<code class="code">basic_blocks fn</code> returns the basic blocks of the function <code class="code">f</code>.
    See the method <code class="code">llvm::<span class="constructor">Function</span>::getBasicBlockList</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALentry_block"></a>entry_block : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllbasicblock">llbasicblock</a></code></pre><div class="info">
<code class="code">entry_block fn</code> returns the entry basic block of the function <code class="code">f</code>.
    See the method <code class="code">llvm::<span class="constructor">Function</span>::getEntryBlock</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALdelete_block"></a>delete_block : <code class="type"><a href="Llvm.html#TYPEllbasicblock">llbasicblock</a> -> unit</code></pre><div class="info">
<code class="code">delete_block bb</code> deletes the basic block <code class="code">bb</code>.
    See the method <code class="code">llvm::<span class="constructor">BasicBlock</span>::eraseFromParent</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALappend_block"></a>append_block : <code class="type"><a href="Llvm.html#TYPEllcontext">llcontext</a> -> string -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllbasicblock">llbasicblock</a></code></pre><div class="info">
<code class="code">append_block c name f</code> creates a new basic block named <code class="code">name</code> at the end of
    function <code class="code">f</code> in the context <code class="code">c</code>.
    See the constructor of <code class="code">llvm::<span class="constructor">BasicBlock</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALinsert_block"></a>insert_block : <code class="type"><a href="Llvm.html#TYPEllcontext">llcontext</a> -> string -> <a href="Llvm.html#TYPEllbasicblock">llbasicblock</a> -> <a href="Llvm.html#TYPEllbasicblock">llbasicblock</a></code></pre><div class="info">
<code class="code">insert_block c name bb</code> creates a new basic block named <code class="code">name</code> before the
    basic block <code class="code">bb</code> in the context <code class="code">c</code>.
    See the constructor of <code class="code">llvm::<span class="constructor">BasicBlock</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALblock_parent"></a>block_parent : <code class="type"><a href="Llvm.html#TYPEllbasicblock">llbasicblock</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">block_parent bb</code> returns the parent function that owns the basic block.
    See the method <code class="code">llvm::<span class="constructor">BasicBlock</span>::getParent</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALblock_begin"></a>block_begin : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> (<a href="Llvm.html#TYPEllvalue">llvalue</a>, <a href="Llvm.html#TYPEllbasicblock">llbasicblock</a>) <a href="Llvm.html#TYPEllpos">llpos</a></code></pre><div class="info">
<code class="code">block_begin f</code> returns the first position in the basic block list of the
    function <code class="code">f</code>. <code class="code">block_begin</code> and <code class="code">block_succ</code> can be used to iterate over
    the basic block list in order.
    See the method <code class="code">llvm::<span class="constructor">Function</span>::<span class="keyword">begin</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALblock_succ"></a>block_succ : <code class="type"><a href="Llvm.html#TYPEllbasicblock">llbasicblock</a> -> (<a href="Llvm.html#TYPEllvalue">llvalue</a>, <a href="Llvm.html#TYPEllbasicblock">llbasicblock</a>) <a href="Llvm.html#TYPEllpos">llpos</a></code></pre><div class="info">
<code class="code">block_succ bb</code> returns the basic block list position succeeding
    <code class="code"><span class="constructor">Before</span> bb</code>.
    See the method <code class="code">llvm::<span class="constructor">Function</span>::iterator::operator++</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALiter_blocks"></a>iter_blocks : <code class="type">(<a href="Llvm.html#TYPEllbasicblock">llbasicblock</a> -> unit) -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> unit</code></pre><div class="info">
<code class="code">iter_blocks f fn</code> applies function <code class="code">f</code> to each of the basic blocks
    of function <code class="code">fn</code> in order. Tail recursive.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfold_left_blocks"></a>fold_left_blocks : <code class="type">('a -> <a href="Llvm.html#TYPEllbasicblock">llbasicblock</a> -> 'a) -> 'a -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> 'a</code></pre><div class="info">
<code class="code">fold_left_blocks f init fn</code> is <code class="code">f (... (f init b1) ...) bN</code> where
    <code class="code">b1,...,bN</code> are the basic blocks of function <code class="code">fn</code>. Tail recursive.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALblock_end"></a>block_end : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> (<a href="Llvm.html#TYPEllvalue">llvalue</a>, <a href="Llvm.html#TYPEllbasicblock">llbasicblock</a>) <a href="Llvm.html#TYPEllrev_pos">llrev_pos</a></code></pre><div class="info">
<code class="code">block_end f</code> returns the last position in the basic block list of
    the function <code class="code">f</code>. <code class="code">block_end</code> and <code class="code">block_pred</code> can be used to iterate
    over the basic block list in reverse.
    See the method <code class="code">llvm::<span class="constructor">Function</span>::<span class="keyword">end</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALblock_pred"></a>block_pred : <code class="type"><a href="Llvm.html#TYPEllbasicblock">llbasicblock</a> -> (<a href="Llvm.html#TYPEllvalue">llvalue</a>, <a href="Llvm.html#TYPEllbasicblock">llbasicblock</a>) <a href="Llvm.html#TYPEllrev_pos">llrev_pos</a></code></pre><div class="info">
<code class="code">block_pred gv</code> returns the function list position preceding <code class="code"><span class="constructor">After</span> gv</code>.
    See the method <code class="code">llvm::<span class="constructor">Function</span>::iterator::operator--</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALrev_iter_blocks"></a>rev_iter_blocks : <code class="type">(<a href="Llvm.html#TYPEllbasicblock">llbasicblock</a> -> unit) -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> unit</code></pre><div class="info">
<code class="code">rev_iter_blocks f fn</code> applies function <code class="code">f</code> to each of the basic blocks
    of function <code class="code">fn</code> in reverse order. Tail recursive.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfold_right_blocks"></a>fold_right_blocks : <code class="type">(<a href="Llvm.html#TYPEllbasicblock">llbasicblock</a> -> 'a -> 'a) -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> 'a -> 'a</code></pre><div class="info">
<code class="code">fold_right_blocks f fn init</code> is <code class="code">f (... (f init bN) ...) b1</code> where
    <code class="code">b1,...,bN</code> are the basic blocks of function <code class="code">fn</code>. Tail recursive.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALvalue_of_block"></a>value_of_block : <code class="type"><a href="Llvm.html#TYPEllbasicblock">llbasicblock</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">value_of_block bb</code> losslessly casts <code class="code">bb</code> to an <code class="code">llvalue</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALvalue_is_block"></a>value_is_block : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> bool</code></pre><div class="info">
<code class="code">value_is_block v</code> returns <code class="code"><span class="keyword">true</span></code> if the value <code class="code">v</code> is a basic block and
    <code class="code"><span class="keyword">false</span></code> otherwise.
    Similar to <code class="code">llvm::isa&lt;<span class="constructor">BasicBlock</span>&gt;</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALblock_of_value"></a>block_of_value : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllbasicblock">llbasicblock</a></code></pre><div class="info">
<code class="code">block_of_value v</code> losslessly casts <code class="code">v</code> to an <code class="code">llbasicblock</code>.<br>
</div>
<br>
<a name="7_Operationsoninstructions"></a>
<div class="h7">Operations on instructions</div><br>
<pre><span class="keyword">val</span> <a name="VALinstr_parent"></a>instr_parent : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllbasicblock">llbasicblock</a></code></pre><div class="info">
<code class="code">instr_parent i</code> is the enclosing basic block of the instruction <code class="code">i</code>.
    See the method <code class="code">llvm::<span class="constructor">Instruction</span>::getParent</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALinstr_begin"></a>instr_begin : <code class="type"><a href="Llvm.html#TYPEllbasicblock">llbasicblock</a> -> (<a href="Llvm.html#TYPEllbasicblock">llbasicblock</a>, <a href="Llvm.html#TYPEllvalue">llvalue</a>) <a href="Llvm.html#TYPEllpos">llpos</a></code></pre><div class="info">
<code class="code">instr_begin bb</code> returns the first position in the instruction list of the
    basic block <code class="code">bb</code>. <code class="code">instr_begin</code> and <code class="code">instr_succ</code> can be used to iterate over
    the instruction list in order.
    See the method <code class="code">llvm::<span class="constructor">BasicBlock</span>::<span class="keyword">begin</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALinstr_succ"></a>instr_succ : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> (<a href="Llvm.html#TYPEllbasicblock">llbasicblock</a>, <a href="Llvm.html#TYPEllvalue">llvalue</a>) <a href="Llvm.html#TYPEllpos">llpos</a></code></pre><div class="info">
<code class="code">instr_succ i</code> returns the instruction list position succeeding <code class="code"><span class="constructor">Before</span> i</code>.
    See the method <code class="code">llvm::<span class="constructor">BasicBlock</span>::iterator::operator++</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALiter_instrs"></a>iter_instrs : <code class="type">(<a href="Llvm.html#TYPEllvalue">llvalue</a> -> unit) -> <a href="Llvm.html#TYPEllbasicblock">llbasicblock</a> -> unit</code></pre><div class="info">
<code class="code">iter_instrs f bb</code> applies function <code class="code">f</code> to each of the instructions of basic
    block <code class="code">bb</code> in order. Tail recursive.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfold_left_instrs"></a>fold_left_instrs : <code class="type">('a -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> 'a) -> 'a -> <a href="Llvm.html#TYPEllbasicblock">llbasicblock</a> -> 'a</code></pre><div class="info">
<code class="code">fold_left_instrs f init bb</code> is <code class="code">f (... (f init g1) ...) gN</code> where
    <code class="code">g1,...,gN</code> are the instructions of basic block <code class="code">bb</code>. Tail recursive.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALinstr_end"></a>instr_end : <code class="type"><a href="Llvm.html#TYPEllbasicblock">llbasicblock</a> -> (<a href="Llvm.html#TYPEllbasicblock">llbasicblock</a>, <a href="Llvm.html#TYPEllvalue">llvalue</a>) <a href="Llvm.html#TYPEllrev_pos">llrev_pos</a></code></pre><div class="info">
<code class="code">instr_end bb</code> returns the last position in the instruction list of the
    basic block <code class="code">bb</code>. <code class="code">instr_end</code> and <code class="code">instr_pred</code> can be used to iterate over
    the instruction list in reverse.
    See the method <code class="code">llvm::<span class="constructor">BasicBlock</span>::<span class="keyword">end</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALinstr_pred"></a>instr_pred : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> (<a href="Llvm.html#TYPEllbasicblock">llbasicblock</a>, <a href="Llvm.html#TYPEllvalue">llvalue</a>) <a href="Llvm.html#TYPEllrev_pos">llrev_pos</a></code></pre><div class="info">
<code class="code">instr_pred i</code> returns the instruction list position preceding <code class="code"><span class="constructor">After</span> i</code>.
    See the method <code class="code">llvm::<span class="constructor">BasicBlock</span>::iterator::operator--</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALfold_right_instrs"></a>fold_right_instrs : <code class="type">(<a href="Llvm.html#TYPEllvalue">llvalue</a> -> 'a -> 'a) -> <a href="Llvm.html#TYPEllbasicblock">llbasicblock</a> -> 'a -> 'a</code></pre><div class="info">
<code class="code">fold_right_instrs f bb init</code> is <code class="code">f (... (f init fN) ...) f1</code> where
    <code class="code">f1,...,fN</code> are the instructions of basic block <code class="code">bb</code>. Tail recursive.<br>
</div>
<br>
<a name="7_Operationsoncallsites"></a>
<div class="h7">Operations on call sites</div><br>
<pre><span class="keyword">val</span> <a name="VALinstruction_call_conv"></a>instruction_call_conv : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> int</code></pre><div class="info">
<code class="code">instruction_call_conv ci</code> is the calling convention for the call or invoke
    instruction <code class="code">ci</code>, which may be one of the values from the module
    <a href="Llvm.CallConv.html"><code class="code"><span class="constructor">Llvm</span>.<span class="constructor">CallConv</span></code></a>. See the method <code class="code">llvm::<span class="constructor">CallInst</span>::getCallingConv</code> and
    <code class="code">llvm::<span class="constructor">InvokeInst</span>::getCallingConv</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALset_instruction_call_conv"></a>set_instruction_call_conv : <code class="type">int -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> unit</code></pre><div class="info">
<code class="code">set_instruction_call_conv cc ci</code> sets the calling convention for the call
    or invoke instruction <code class="code">ci</code> to the integer <code class="code">cc</code>, which can be one of the
    values from the module <a href="Llvm.CallConv.html"><code class="code"><span class="constructor">Llvm</span>.<span class="constructor">CallConv</span></code></a>.
    See the method <code class="code">llvm::<span class="constructor">CallInst</span>::setCallingConv</code>
    and <code class="code">llvm::<span class="constructor">InvokeInst</span>::setCallingConv</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALadd_instruction_param_attr"></a>add_instruction_param_attr : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> int -> <a href="Llvm.Attribute.html#TYPEt">Attribute.t</a> -> unit</code></pre><div class="info">
<code class="code">add_instruction_param_attr ci i a</code> adds attribute <code class="code">a</code> to the <code class="code">i</code>th
    parameter of the call or invoke instruction <code class="code">ci</code>. <code class="code">i</code>=0 denotes the return
    value.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALremove_instruction_param_attr"></a>remove_instruction_param_attr : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> int -> <a href="Llvm.Attribute.html#TYPEt">Attribute.t</a> -> unit</code></pre><div class="info">
<code class="code">remove_instruction_param_attr ci i a</code> removes attribute <code class="code">a</code> from the
    <code class="code">i</code>th parameter of the call or invoke instruction <code class="code">ci</code>. <code class="code">i</code>=0 denotes the
    return value.<br>
</div>
<br>
<br>
<pre><span class="keyword">val</span> <a name="VALis_tail_call"></a>is_tail_call : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> bool</code></pre><div class="info">
<code class="code">is_tail_call ci</code> is <code class="code"><span class="keyword">true</span></code> if the call instruction <code class="code">ci</code> is flagged as
    eligible for tail call optimization, <code class="code"><span class="keyword">false</span></code> otherwise.
    See the method <code class="code">llvm::<span class="constructor">CallInst</span>::isTailCall</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALset_tail_call"></a>set_tail_call : <code class="type">bool -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> unit</code></pre><div class="info">
<code class="code">set_tail_call tc ci</code> flags the call instruction <code class="code">ci</code> as eligible for tail
    call optimization if <code class="code">tc</code> is <code class="code"><span class="keyword">true</span></code>, clears otherwise.
    See the method <code class="code">llvm::<span class="constructor">CallInst</span>::setTailCall</code>.<br>
</div>
<br>
<a name="7_Operationsonphinodes"></a>
<div class="h7">Operations on phi nodes</div><br>
<pre><span class="keyword">val</span> <a name="VALadd_incoming"></a>add_incoming : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> * <a href="Llvm.html#TYPEllbasicblock">llbasicblock</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> unit</code></pre><div class="info">
<code class="code">add_incoming (v, bb) pn</code> adds the value <code class="code">v</code> to the phi node <code class="code">pn</code> for use
    with branches from <code class="code">bb</code>. See the method <code class="code">llvm::<span class="constructor">PHINode</span>::addIncoming</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALincoming"></a>incoming : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> (<a href="Llvm.html#TYPEllvalue">llvalue</a> * <a href="Llvm.html#TYPEllbasicblock">llbasicblock</a>) list</code></pre><div class="info">
<code class="code">incoming pn</code> returns the list of value-block pairs for phi node <code class="code">pn</code>.
    See the method <code class="code">llvm::<span class="constructor">PHINode</span>::getIncomingValue</code>.<br>
</div>
<br>
<a name="6_Instructionbuilders"></a>
<h6>Instruction builders</h6><br>
<pre><span class="keyword">val</span> <a name="VALbuilder"></a>builder : <code class="type"><a href="Llvm.html#TYPEllcontext">llcontext</a> -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a></code></pre><div class="info">
<code class="code">builder context</code> creates an instruction builder with no position in
    the context <code class="code">context</code>. It is invalid to use this builder until its position
    is set with <a href="Llvm.html#VALposition_before"><code class="code"><span class="constructor">Llvm</span>.position_before</code></a> or <a href="Llvm.html#VALposition_at_end"><code class="code"><span class="constructor">Llvm</span>.position_at_end</code></a>. See the constructor
    for <code class="code">llvm::<span class="constructor">LLVMBuilder</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuilder_at"></a>builder_at : <code class="type"><a href="Llvm.html#TYPEllcontext">llcontext</a> -><br>       (<a href="Llvm.html#TYPEllbasicblock">llbasicblock</a>, <a href="Llvm.html#TYPEllvalue">llvalue</a>) <a href="Llvm.html#TYPEllpos">llpos</a> -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a></code></pre><div class="info">
<code class="code">builder_at ip</code> creates an instruction builder positioned at <code class="code">ip</code>.
    See the constructor for <code class="code">llvm::<span class="constructor">LLVMBuilder</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuilder_before"></a>builder_before : <code class="type"><a href="Llvm.html#TYPEllcontext">llcontext</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a></code></pre><div class="info">
<code class="code">builder_before ins</code> creates an instruction builder positioned before the
    instruction <code class="code">isn</code>. See the constructor for <code class="code">llvm::<span class="constructor">LLVMBuilder</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuilder_at_end"></a>builder_at_end : <code class="type"><a href="Llvm.html#TYPEllcontext">llcontext</a> -> <a href="Llvm.html#TYPEllbasicblock">llbasicblock</a> -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a></code></pre><div class="info">
<code class="code">builder_at_end bb</code> creates an instruction builder positioned at the end of
    the basic block <code class="code">bb</code>. See the constructor for <code class="code">llvm::<span class="constructor">LLVMBuilder</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALposition_builder"></a>position_builder : <code class="type">(<a href="Llvm.html#TYPEllbasicblock">llbasicblock</a>, <a href="Llvm.html#TYPEllvalue">llvalue</a>) <a href="Llvm.html#TYPEllpos">llpos</a> -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> unit</code></pre><div class="info">
<code class="code">position_builder ip bb</code> moves the instruction builder <code class="code">bb</code> to the position
    <code class="code">ip</code>.
    See the constructor for <code class="code">llvm::<span class="constructor">LLVMBuilder</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALposition_before"></a>position_before : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> unit</code></pre><div class="info">
<code class="code">position_before ins b</code> moves the instruction builder <code class="code">b</code> to before the
    instruction <code class="code">isn</code>. See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">SetInsertPoint</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALposition_at_end"></a>position_at_end : <code class="type"><a href="Llvm.html#TYPEllbasicblock">llbasicblock</a> -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> unit</code></pre><div class="info">
<code class="code">position_at_end bb b</code> moves the instruction builder <code class="code">b</code> to the end of the
    basic block <code class="code">bb</code>. See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">SetInsertPoint</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALinsertion_block"></a>insertion_block : <code class="type"><a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllbasicblock">llbasicblock</a></code></pre><div class="info">
<code class="code">insertion_block b</code> returns the basic block that the builder <code class="code">b</code> is
    positioned to insert into. Raises <code class="code"><span class="constructor">Not_Found</span></code> if the instruction builder is
    uninitialized.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">GetInsertBlock</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALinsert_into_builder"></a>insert_into_builder : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> unit</code></pre><div class="info">
<code class="code">insert_into_builder i name b</code> inserts the specified instruction <code class="code">i</code> at the
    position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">Insert</span></code>.<br>
</div>
<br>
<a name="7_Metadata"></a>
<div class="h7">Metadata</div><br>
<pre><span class="keyword">val</span> <a name="VALset_current_debug_location"></a>set_current_debug_location : <code class="type"><a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> unit</code></pre><div class="info">
<code class="code">set_current_debug_location b md</code> sets the current debug location <code class="code">md</code> in
    the builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">IRBuilder</span>::<span class="constructor">SetDebugLocation</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALclear_current_debug_location"></a>clear_current_debug_location : <code class="type"><a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> unit</code></pre><div class="info">
<code class="code">clear_current_debug_location b</code> clears the current debug location in the
    builder <code class="code">b</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALcurrent_debug_location"></a>current_debug_location : <code class="type"><a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> option</code></pre><div class="info">
<code class="code">current_debug_location b</code> returns the current debug location, or None
    if none is currently set.
    See the method <code class="code">llvm::<span class="constructor">IRBuilder</span>::<span class="constructor">GetDebugLocation</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALset_inst_debug_location"></a>set_inst_debug_location : <code class="type"><a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> unit</code></pre><div class="info">
<code class="code">set_inst_debug_location b i</code> sets the current debug location of the builder
    <code class="code">b</code> to the instruction <code class="code">i</code>.
    See the method <code class="code">llvm::<span class="constructor">IRBuilder</span>::<span class="constructor">SetInstDebugLocation</span></code>.<br>
</div>
<br>
<a name="7_Terminators"></a>
<div class="h7">Terminators</div><br>
<pre><span class="keyword">val</span> <a name="VALbuild_ret_void"></a>build_ret_void : <code class="type"><a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_ret_void b</code> creates a
    <code class="code">ret void</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateRetVoid</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_ret"></a>build_ret : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_ret v b</code> creates a
    <code class="code">ret %v</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateRet</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_aggregate_ret"></a>build_aggregate_ret : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> array -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_aggregate_ret vs b</code> creates a
    <code class="code">ret {...} { %v1, %v2, ... } </code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateAggregateRet</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_br"></a>build_br : <code class="type"><a href="Llvm.html#TYPEllbasicblock">llbasicblock</a> -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_br bb b</code> creates a
    <code class="code">br %bb</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateBr</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_cond_br"></a>build_cond_br : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -><br>       <a href="Llvm.html#TYPEllbasicblock">llbasicblock</a> -> <a href="Llvm.html#TYPEllbasicblock">llbasicblock</a> -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_cond_br cond tbb fbb b</code> creates a
    <code class="code">br %cond, %tbb, %fbb</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateCondBr</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_switch"></a>build_switch : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllbasicblock">llbasicblock</a> -> int -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_switch case elsebb count b</code> creates an empty
    <code class="code">switch %case, %elsebb</code>
    instruction at the position specified by the instruction builder <code class="code">b</code> with
    space reserved for <code class="code">count</code> cases.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateSwitch</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALadd_case"></a>add_case : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllbasicblock">llbasicblock</a> -> unit</code></pre><div class="info">
<code class="code">add_case sw onval bb</code> causes switch instruction <code class="code">sw</code> to branch to <code class="code">bb</code>
    when its input matches the constant <code class="code">onval</code>.
    See the method <code class="code">llvm::<span class="constructor">SwitchInst</span>::addCase</code>. *<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_indirect_br"></a>build_indirect_br : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> int -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_indirect_br addr count b</code> creates a
    <code class="code">indirectbr %addr</code>
    instruction at the position specified by the instruction builder <code class="code">b</code> with
    space reserved for <code class="code">count</code> destinations.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateIndirectBr</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALadd_destination"></a>add_destination : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllbasicblock">llbasicblock</a> -> unit</code></pre><div class="info">
<code class="code">add_destination br bb</code> adds the basic block <code class="code">bb</code> as a possible branch
    location for the indirectbr instruction <code class="code">br</code>.
    See the method <code class="code">llvm::<span class="constructor">IndirectBrInst</span>::addDestination</code>. *<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_invoke"></a>build_invoke : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -><br>       <a href="Llvm.html#TYPEllvalue">llvalue</a> array -><br>       <a href="Llvm.html#TYPEllbasicblock">llbasicblock</a> -><br>       <a href="Llvm.html#TYPEllbasicblock">llbasicblock</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_invoke fn args tobb unwindbb name b</code> creates an
    <code class="code">%name = invoke %fn(args) <span class="keyword">to</span> %tobb unwind %unwindbb</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateInvoke</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_unwind"></a>build_unwind : <code class="type"><a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_unwind b</code> creates an
    <code class="code">unwind</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateUnwind</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_unreachable"></a>build_unreachable : <code class="type"><a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_unreachable b</code> creates an
    <code class="code">unreachable</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateUnwind</span></code>.<br>
</div>
<br>
<a name="7_Arithmetic"></a>
<div class="h7">Arithmetic</div><br>
<pre><span class="keyword">val</span> <a name="VALbuild_add"></a>build_add : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_add x y name b</code> creates a
    <code class="code">%name = add %x, %y</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateAdd</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_nsw_add"></a>build_nsw_add : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_nsw_add x y name b</code> creates a
    <code class="code">%name = nsw add %x, %y</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateNSWAdd</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_nuw_add"></a>build_nuw_add : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_nuw_add x y name b</code> creates a
    <code class="code">%name = nuw add %x, %y</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateNUWAdd</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_fadd"></a>build_fadd : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_fadd x y name b</code> creates a
    <code class="code">%name = fadd %x, %y</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateFAdd</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_sub"></a>build_sub : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_sub x y name b</code> creates a
    <code class="code">%name = sub %x, %y</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateSub</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_nsw_sub"></a>build_nsw_sub : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_nsw_sub x y name b</code> creates a
    <code class="code">%name = nsw sub %x, %y</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateNSWSub</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_nuw_sub"></a>build_nuw_sub : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_nuw_sub x y name b</code> creates a
    <code class="code">%name = nuw sub %x, %y</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateNUWSub</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_fsub"></a>build_fsub : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_fsub x y name b</code> creates a
    <code class="code">%name = fsub %x, %y</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateFSub</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_mul"></a>build_mul : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_mul x y name b</code> creates a
    <code class="code">%name = mul %x, %y</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateMul</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_nsw_mul"></a>build_nsw_mul : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_nsw_mul x y name b</code> creates a
    <code class="code">%name = nsw mul %x, %y</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateNSWMul</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_nuw_mul"></a>build_nuw_mul : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_nuw_mul x y name b</code> creates a
    <code class="code">%name = nuw mul %x, %y</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateNUWMul</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_fmul"></a>build_fmul : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_fmul x y name b</code> creates a
    <code class="code">%name = fmul %x, %y</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateFMul</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_udiv"></a>build_udiv : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_udiv x y name b</code> creates a
    <code class="code">%name = udiv %x, %y</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateUDiv</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_sdiv"></a>build_sdiv : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_sdiv x y name b</code> creates a
    <code class="code">%name = sdiv %x, %y</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateSDiv</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_exact_sdiv"></a>build_exact_sdiv : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_exact_sdiv x y name b</code> creates a
    <code class="code">%name = exact sdiv %x, %y</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateExactSDiv</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_fdiv"></a>build_fdiv : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_fdiv x y name b</code> creates a
    <code class="code">%name = fdiv %x, %y</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateFDiv</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_urem"></a>build_urem : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_urem x y name b</code> creates a
    <code class="code">%name = urem %x, %y</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateURem</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_srem"></a>build_srem : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_SRem x y name b</code> creates a
    <code class="code">%name = srem %x, %y</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateSRem</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_frem"></a>build_frem : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_frem x y name b</code> creates a
    <code class="code">%name = frem %x, %y</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateFRem</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_shl"></a>build_shl : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_shl x y name b</code> creates a
    <code class="code">%name = shl %x, %y</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateShl</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_lshr"></a>build_lshr : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_lshr x y name b</code> creates a
    <code class="code">%name = lshr %x, %y</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateLShr</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_ashr"></a>build_ashr : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_ashr x y name b</code> creates a
    <code class="code">%name = ashr %x, %y</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateAShr</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_and"></a>build_and : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_and x y name b</code> creates a
    <code class="code">%name = <span class="keyword">and</span> %x, %y</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateAnd</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_or"></a>build_or : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_or x y name b</code> creates a
    <code class="code">%name = <span class="keyword">or</span> %x, %y</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateOr</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_xor"></a>build_xor : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_xor x y name b</code> creates a
    <code class="code">%name = xor %x, %y</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateXor</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_neg"></a>build_neg : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_neg x name b</code> creates a
    <code class="code">%name = sub 0, %x</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    <code class="code">-0.0</code> is used for floating point types to compute the correct sign.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateNeg</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_nsw_neg"></a>build_nsw_neg : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_nsw_neg x name b</code> creates a
    <code class="code">%name = nsw sub 0, %x</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    <code class="code">-0.0</code> is used for floating point types to compute the correct sign.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateNeg</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_nuw_neg"></a>build_nuw_neg : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_nuw_neg x name b</code> creates a
    <code class="code">%name = nuw sub 0, %x</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    <code class="code">-0.0</code> is used for floating point types to compute the correct sign.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateNeg</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_fneg"></a>build_fneg : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_fneg x name b</code> creates a
    <code class="code">%name = fsub 0, %x</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    <code class="code">-0.0</code> is used for floating point types to compute the correct sign.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateFNeg</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_not"></a>build_not : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_xor x name b</code> creates a
    <code class="code">%name = xor %x, -1</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    <code class="code">-1</code> is the correct "all ones" value for the type of <code class="code">x</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateXor</span></code>.<br>
</div>
<br>
<a name="7_Memory"></a>
<div class="h7">Memory</div><br>
<pre><span class="keyword">val</span> <a name="VALbuild_alloca"></a>build_alloca : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_alloca ty name b</code> creates a
    <code class="code">%name = alloca %ty</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateAlloca</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_array_alloca"></a>build_array_alloca : <code class="type"><a href="Llvm.html#TYPElltype">lltype</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_array_alloca ty n name b</code> creates a
    <code class="code">%name = alloca %ty, %n</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateAlloca</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_load"></a>build_load : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_load v name b</code> creates a
    <code class="code">%name = load %v</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateLoad</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_store"></a>build_store : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_store v p b</code> creates a
    <code class="code">store %v, %p</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateStore</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_gep"></a>build_gep : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -><br>       <a href="Llvm.html#TYPEllvalue">llvalue</a> array -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_gep p indices name b</code> creates a
    <code class="code">%name = getelementptr %p, indices...</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateGetElementPtr</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_in_bounds_gep"></a>build_in_bounds_gep : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -><br>       <a href="Llvm.html#TYPEllvalue">llvalue</a> array -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_in_bounds_gep p indices name b</code> creates a
    <code class="code">%name = gelementptr inbounds %p, indices...</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateInBoundsGetElementPtr</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_struct_gep"></a>build_struct_gep : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> int -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_struct_gep p idx name b</code> creates a
    <code class="code">%name = getelementptr %p, 0, idx</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateStructGetElementPtr</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_global_string"></a>build_global_string : <code class="type">string -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_global_string str name b</code> creates a series of instructions that adds
    a global string at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateGlobalString</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_global_stringptr"></a>build_global_stringptr : <code class="type">string -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_global_stringptr str name b</code> creates a series of instructions that
    adds a global string pointer at the position specified by the instruction
    builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateGlobalStringPtr</span></code>.<br>
</div>
<br>
<a name="7_Casts"></a>
<div class="h7">Casts</div><br>
<pre><span class="keyword">val</span> <a name="VALbuild_trunc"></a>build_trunc : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_trunc v ty name b</code> creates a
    <code class="code">%name = trunc %p <span class="keyword">to</span> %ty</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateTrunc</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_zext"></a>build_zext : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_zext v ty name b</code> creates a
    <code class="code">%name = zext %p <span class="keyword">to</span> %ty</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateZExt</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_sext"></a>build_sext : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_sext v ty name b</code> creates a
    <code class="code">%name = sext %p <span class="keyword">to</span> %ty</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateSExt</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_fptoui"></a>build_fptoui : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_fptoui v ty name b</code> creates a
    <code class="code">%name = fptoui %p <span class="keyword">to</span> %ty</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateFPToUI</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_fptosi"></a>build_fptosi : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_fptosi v ty name b</code> creates a
    <code class="code">%name = fptosi %p <span class="keyword">to</span> %ty</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateFPToSI</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_uitofp"></a>build_uitofp : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_uitofp v ty name b</code> creates a
    <code class="code">%name = uitofp %p <span class="keyword">to</span> %ty</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateUIToFP</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_sitofp"></a>build_sitofp : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_sitofp v ty name b</code> creates a
    <code class="code">%name = sitofp %p <span class="keyword">to</span> %ty</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateSIToFP</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_fptrunc"></a>build_fptrunc : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_fptrunc v ty name b</code> creates a
    <code class="code">%name = fptrunc %p <span class="keyword">to</span> %ty</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateFPTrunc</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_fpext"></a>build_fpext : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_fpext v ty name b</code> creates a
    <code class="code">%name = fpext %p <span class="keyword">to</span> %ty</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateFPExt</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_ptrtoint"></a>build_ptrtoint : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_ptrtoint v ty name b</code> creates a
    <code class="code">%name = prtotint %p <span class="keyword">to</span> %ty</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreatePtrToInt</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_inttoptr"></a>build_inttoptr : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_inttoptr v ty name b</code> creates a
    <code class="code">%name = inttoptr %p <span class="keyword">to</span> %ty</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateIntToPtr</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_bitcast"></a>build_bitcast : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_bitcast v ty name b</code> creates a
    <code class="code">%name = bitcast %p <span class="keyword">to</span> %ty</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateBitCast</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_zext_or_bitcast"></a>build_zext_or_bitcast : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_zext_or_bitcast v ty name b</code> creates a zext or bitcast
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateZExtOrBitCast</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_sext_or_bitcast"></a>build_sext_or_bitcast : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_sext_or_bitcast v ty name b</code> creates a sext or bitcast
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateSExtOrBitCast</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_trunc_or_bitcast"></a>build_trunc_or_bitcast : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_trunc_or_bitcast v ty name b</code> creates a trunc or bitcast
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateZExtOrBitCast</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_pointercast"></a>build_pointercast : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_pointercast v ty name b</code> creates a bitcast or pointer-to-int
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreatePointerCast</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_intcast"></a>build_intcast : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_intcast v ty name b</code> creates a zext, bitcast, or trunc
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateIntCast</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_fpcast"></a>build_fpcast : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_fpcast v ty name b</code> creates a fpext, bitcast, or fptrunc
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateFPCast</span></code>.<br>
</div>
<br>
<a name="7_Comparisons"></a>
<div class="h7">Comparisons</div><br>
<pre><span class="keyword">val</span> <a name="VALbuild_icmp"></a>build_icmp : <code class="type"><a href="Llvm.Icmp.html#TYPEt">Icmp.t</a> -><br>       <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_icmp pred x y name b</code> creates a
    <code class="code">%name = icmp %pred %x, %y</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateICmp</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_fcmp"></a>build_fcmp : <code class="type"><a href="Llvm.Fcmp.html#TYPEt">Fcmp.t</a> -><br>       <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_fcmp pred x y name b</code> creates a
    <code class="code">%name = fcmp %pred %x, %y</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateFCmp</span></code>.<br>
</div>
<br>
<a name="7_Miscellaneousinstructions"></a>
<div class="h7">Miscellaneous instructions</div><br>
<pre><span class="keyword">val</span> <a name="VALbuild_phi"></a>build_phi : <code class="type">(<a href="Llvm.html#TYPEllvalue">llvalue</a> * <a href="Llvm.html#TYPEllbasicblock">llbasicblock</a>) list -><br>       string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_phi incoming name b</code> creates a
    <code class="code">%name = phi %incoming</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    <code class="code">incoming</code> is a list of <code class="code">(llvalue, llbasicblock)</code> tuples.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreatePHI</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_call"></a>build_call : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -><br>       <a href="Llvm.html#TYPEllvalue">llvalue</a> array -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_call fn args name b</code> creates a
    <code class="code">%name = call %fn(args...)</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateCall</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_select"></a>build_select : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -><br>       <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_select cond thenv elsev name b</code> creates a
    <code class="code">%name = select %cond, %thenv, %elsev</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateSelect</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_va_arg"></a>build_va_arg : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPElltype">lltype</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_va_arg valist argty name b</code> creates a
    <code class="code">%name = va_arg %valist, %argty</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateVAArg</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_extractelement"></a>build_extractelement : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_extractelement vec i name b</code> creates a
    <code class="code">%name = extractelement %vec, %i</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateExtractElement</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_insertelement"></a>build_insertelement : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -><br>       <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_insertelement vec elt i name b</code> creates a
    <code class="code">%name = insertelement %vec, %elt, %i</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateInsertElement</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_shufflevector"></a>build_shufflevector : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -><br>       <a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_shufflevector veca vecb mask name b</code> creates a
    <code class="code">%name = shufflevector %veca, %vecb, %mask</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateShuffleVector</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_extractvalue"></a>build_extractvalue : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> int -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_insertvalue agg idx name b</code> creates a
    <code class="code">%name = extractvalue %agg, %idx</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateExtractValue</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_insertvalue"></a>build_insertvalue : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -><br>       <a href="Llvm.html#TYPEllvalue">llvalue</a> -> int -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_insertvalue agg <span class="keyword">val</span> idx name b</code> creates a
    <code class="code">%name = insertvalue %agg, %<span class="keyword">val</span>, %idx</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateInsertValue</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_is_null"></a>build_is_null : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_is_null <span class="keyword">val</span> name b</code> creates a
    <code class="code">%name = icmp eq %<span class="keyword">val</span>, null</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateIsNull</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_is_not_null"></a>build_is_not_null : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_is_not_null <span class="keyword">val</span> name b</code> creates a
    <code class="code">%name = icmp ne %<span class="keyword">val</span>, null</code>
    instruction at the position specified by the instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreateIsNotNull</span></code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALbuild_ptrdiff"></a>build_ptrdiff : <code class="type"><a href="Llvm.html#TYPEllvalue">llvalue</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a> -> string -> <a href="Llvm.html#TYPEllbuilder">llbuilder</a> -> <a href="Llvm.html#TYPEllvalue">llvalue</a></code></pre><div class="info">
<code class="code">build_ptrdiff lhs rhs name b</code> creates a series of instructions that measure
    the difference between two pointer values at the position specified by the
    instruction builder <code class="code">b</code>.
    See the method <code class="code">llvm::<span class="constructor">LLVMBuilder</span>::<span class="constructor">CreatePtrDiff</span></code>.<br>
</div>
<br>
<a name="6_Memorybuffers"></a>
<h6>Memory buffers</h6><br>
<pre><span class="keyword">module</span> <a href="Llvm.MemoryBuffer.html">MemoryBuffer</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Llvm.MemoryBuffer.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><br>
<a name="6_PassManagers"></a>
<h6>Pass Managers</h6><br>
<pre><span class="keyword">module</span> <a href="Llvm.PassManager.html">PassManager</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Llvm.PassManager.html">..</a> <code class="code"><span class="keyword">end</span></code></pre></body></html>