//===-- RigelISelDAGToDAG.cpp - A dag to dag inst selector for Rigel --------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file defines an instruction selector for the Rigel target.
//
//===----------------------------------------------------------------------===//

#define DEBUG_TYPE "rigel-dag"
#include "Rigel.h"
#include "RigelMachineFunction.h"
#include "RigelRegisterInfo.h"
#include "RigelSubtarget.h"
#include "RigelTargetMachine.h"
#include "llvm/GlobalValue.h"
#include "llvm/Instructions.h"
#include "llvm/Intrinsics.h"
#include "llvm/Support/CFG.h"
#include "llvm/Type.h"
#include "llvm/CodeGen/MachineConstantPool.h"
#include "llvm/CodeGen/MachineFunction.h"
#include "llvm/CodeGen/MachineFrameInfo.h"
#include "llvm/CodeGen/MachineInstrBuilder.h"
#include "llvm/CodeGen/MachineRegisterInfo.h"
#include "llvm/CodeGen/SelectionDAGISel.h"
#include "llvm/Target/TargetMachine.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/Support/raw_ostream.h"

using namespace llvm;

//===----------------------------------------------------------------------===//
// Instruction Selector Implementation
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
// RigelDAGToDAGISel - Target-specific code for replacing SDNodes with other
// SDNodes
//===----------------------------------------------------------------------===//
namespace {

class RigelDAGToDAGISel : public SelectionDAGISel {

  /// TM - Keep a reference to RigelTargetMachine.
  RigelTargetMachine &TM;

  /// Subtarget - Keep a pointer to the RigelSubtarget around so that we can
  /// make the right decision when generating code for different targets.
  const RigelSubtarget &Subtarget;
 
public:
  explicit RigelDAGToDAGISel(RigelTargetMachine &tm) :
  SelectionDAGISel(tm),
  TM(tm), Subtarget(*tm.getSubtargetImpl()) {}
  
  // Pass Name
  virtual const char *getPassName() const {
    return "RIGEL DAG->DAG Pattern Instruction Selection";
  } 

  /// SelectInlineAsmMemoryOperand - Select the specified address as a target
  /// addressing mode, according to the specified constraint code.  If this does
  /// not match or is not implemented, return true.  The resultant operands
  /// (which will appear in the machine instruction) should be added to the
  /// OutOps vector.
  virtual bool SelectInlineAsmMemoryOperand(const SDValue &Op,
                                            char ConstraintCode,
                                            std::vector<SDValue> &OutOps) {
    SDValue Op0, Op1;
		
    switch (ConstraintCode) {
      default: return true;
      case 'm':   // memory
        switch (Op.getOpcode()) {
          case (ISD::Constant) : {
            return true;
          }
          case (ISD::ConstantPool) : {
            return true;
          }
          case (ISD::GlobalAddress) : {
            return true;
          }
          case (ISD::FrameIndex) : {
	          SelectAddr(Op.getNode(), Op, Op0, Op1);
            OutOps.push_back(Op0);
            OutOps.push_back(Op1);
            return false;
          }
          case (ISD::ExternalSymbol) : {
            return true;
          }
          case (ISD::GlobalTLSAddress) : {
            return true;
          }
          case (ISD::ConstantFP) : {
            return true;
          }
          default : {
            SelectAddr(Op.getNode(), Op, Op0, Op1);
            //OutOps.push_back(Op0);
            //OutOps.push_back(Op1);
            OutOps.push_back(Op);
            return false;
          }
        }
        break;
      }
      
    return false;
  }
  
private:  
  // Include the pieces autogenerated from the target description.
  #include "RigelGenDAGISel.inc"

  /// getTargetMachine - Return a reference to the TargetMachine, casted
  /// to the target-specific type.
  const RigelTargetMachine &getTargetMachine() {
    return static_cast<const RigelTargetMachine &>(TM);
  }

  /// getInstrInfo - Return a reference to the TargetInstrInfo, casted
  /// to the target-specific type.
  const RigelInstrInfo *getInstrInfo() {
    return getTargetMachine().getInstrInfo();
  }

  SDNode *getGlobalBaseReg();
  SDNode *Select(SDNode *N);

  // Complex Pattern.
  bool SelectAddr(SDNode *Op, SDValue N, 
                  SDValue &Base, SDValue &Offset);


  // getI32Imm - Return a target constant with the specified
  // value, of type i32.
  inline SDValue getI32Imm(unsigned Imm) {
    return CurDAG->getTargetConstant(Imm, MVT::i32);
  }

  // value, of type i16.
  inline SDValue getI16Imm(unsigned Imm) {
    return CurDAG->getTargetConstant(Imm, MVT::i16);
  }

};

}

/// getGlobalBaseReg - Output the instructions required to put the
/// GOT address into a register.
SDNode *RigelDAGToDAGISel::getGlobalBaseReg() {
  unsigned GlobalBaseReg = getInstrInfo()->getGlobalBaseReg(MF);
  return CurDAG->getRegister(GlobalBaseReg, TLI.getPointerTy()).getNode();
}

/// ComplexPattern used on RigelInstrInfo
/// Used on Rigel Load/Store instructions
bool RigelDAGToDAGISel::
SelectAddr(SDNode *Op, SDValue Addr, SDValue &Offset, SDValue &Base)
{
  // if Address is FI, get the TargetFrameIndex.
  if (FrameIndexSDNode *FIN = dyn_cast<FrameIndexSDNode>(Addr)) {
    Base   = CurDAG->getTargetFrameIndex(FIN->getIndex(), MVT::i32);
    Offset = CurDAG->getTargetConstant(0, MVT::i32);
    return true;
  }
    
  // on PIC code Load from GP
  if (TM.getRelocationModel() == Reloc::PIC_) {
    if ((Addr.getOpcode() == ISD::TargetGlobalAddress) || 
        (Addr.getOpcode() == ISD::TargetConstantPool) ||
        (Addr.getOpcode() == ISD::TargetJumpTable)){
      Base   = CurDAG->getRegister(Rigel::GP, MVT::i32);
      Offset = Addr;
      return true;
    }
  } else {
    if ((Addr.getOpcode() == ISD::TargetExternalSymbol ||
        Addr.getOpcode() == ISD::TargetGlobalAddress)) {
      return false;
    }
  }    
  
  // Operand is a result from an ADD.
  if (Addr.getOpcode() == ISD::ADD) {
    if (ConstantSDNode *CN = dyn_cast<ConstantSDNode>(Addr.getOperand(1))) {
      if (isInt<16>(CN->getSExtValue())) {

        // If the first operand is a FI, get the TargetFI Node
        if (FrameIndexSDNode *FIN = dyn_cast<FrameIndexSDNode>
                                    (Addr.getOperand(0))) {
          Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), MVT::i32);
        } else {
          Base = Addr.getOperand(0);
        }

        Offset = CurDAG->getTargetConstant(CN->getZExtValue(), MVT::i32);
        return true;
      }
    }

    // When loading from constant pools, load the lower address part in
    // the instruction itself. Example, instead of:
    //  mvui $r2, %hi($CPI1_0)
    //  addi $r2, $r2, %lo($CPI1_0)
    //  ldw  $r3, $r2, 0
    // Generate:
    //  mvui $r2, %hi($CPI1_0)
    //  ldw  $r3, $r2, %lo($CPI1_0)
    if ((Addr.getOperand(0).getOpcode() == RigelISD::Hi || 
         Addr.getOperand(0).getOpcode() == ISD::LOAD) &&
        Addr.getOperand(1).getOpcode() == RigelISD::Lo) {
      SDValue LoVal = Addr.getOperand(1); 
      if (dyn_cast<ConstantPoolSDNode>(LoVal.getOperand(0))) {
        Base = Addr.getOperand(0);
        Offset = LoVal.getOperand(0);
        return true;
      }
    }
  }

  Base = Addr;
  Offset = CurDAG->getTargetConstant(0, MVT::i32);
  return true;
}

/// Select instructions not customized! Used for
/// expanded, promoted and normal instructions
SDNode* RigelDAGToDAGISel:: Select(SDNode *Node) {
  unsigned Opcode = Node->getOpcode();
  DebugLoc dl = Node->getDebugLoc();

  // If we have a custom node, we already have selected!
  if (Node->isMachineOpcode()) {
    return NULL;
  }

  ///
  // Instruction Selection not handled by the auto-generated 
  // tablegen selection should be handled here.
  /// 
  switch(Opcode) {
    default: break;
    case ISD::FrameIndex: {
      SDValue imm = CurDAG->getTargetConstant(0, MVT::i32);
      int FI = dyn_cast<FrameIndexSDNode>(Node)->getIndex();
      EVT VT = Node->getValueType(0);
      SDValue TFI = CurDAG->getTargetFrameIndex(FI, VT);
      unsigned Opc = Rigel::ADDi;
      if (Node->hasOneUse())
        return CurDAG->SelectNodeTo(Node, Opc, VT, TFI, imm);
      return CurDAG->getMachineNode(Opc, dl, VT, TFI, imm);
    }

    //FIXME Keeping special muls/divs commented out for now, only need ADDE/SUBE to fix bug 9.
    //TODO Understand whether or not we need these
    #if 0
    /// Mul/Div with two results
    case ISD::SDIVREM:
    case ISD::UDIVREM:
    case ISD::SMUL_LOHI:
    case ISD::UMUL_LOHI: {
      SDValue Op1 = Node->getOperand(0);
      SDValue Op2 = Node->getOperand(1);
      AddToISelQueue(Op1);
      AddToISelQueue(Op2);

      unsigned Op;
      if (Opcode == ISD::UMUL_LOHI || Opcode == ISD::SMUL_LOHI)
        Op = (Opcode == ISD::UMUL_LOHI ? Rigel::MULTu : Rigel::MULT);
      else
        Op = (Opcode == ISD::UDIVREM ? Rigel::DIVu : Rigel::DIV);

      SDNode *Node = CurDAG->getTargetNode(Op, MVT::Flag, Op1, Op2);

      SDValue InFlag = SDValue(Node, 0);
      SDNode *Lo = CurDAG->getTargetNode(Rigel::MFLO, MVT::i32, 
                                         MVT::Flag, InFlag);
      InFlag = SDValue(Lo,1);
      SDNode *Hi = CurDAG->getTargetNode(Rigel::MFHI, MVT::i32, InFlag);

      if (!N.getValue(0).use_empty()) 
        ReplaceUses(N.getValue(0), SDValue(Lo,0));

      if (!N.getValue(1).use_empty()) 
        ReplaceUses(N.getValue(1), SDValue(Hi,0));

      return NULL;
    }

    /// Special Muls
    case ISD::MUL: 
    case ISD::MULHS:
    case ISD::MULHU: {
      SDValue MulOp1 = Node->getOperand(0);
      SDValue MulOp2 = Node->getOperand(1);
      AddToISelQueue(MulOp1);
      AddToISelQueue(MulOp2);

      unsigned MulOp  = (Opcode == ISD::MULHU ? Rigel::MUL : Rigel::MUL);
      SDNode *MulNode = CurDAG->getTargetNode(MulOp, MVT::Flag, MulOp1, MulOp2);

      SDValue InFlag = SDValue(MulNode, 0);

      if (MulOp == ISD::MUL)
        return CurDAG->getTargetNode(Rigel::MFLO, MVT::i32, InFlag);
      else
        return CurDAG->getTargetNode(Rigel::MFHI, MVT::i32, InFlag);
    }

    /// Div/Rem operations
    case ISD::SREM:
    case ISD::UREM:
    case ISD::SDIV: 
    case ISD::UDIV: {
      SDValue Op1 = Node->getOperand(0);
      SDValue Op2 = Node->getOperand(1);
      AddToISelQueue(Op1);
      AddToISelQueue(Op2);

      unsigned Op, MOp;
      if (Opcode == ISD::SDIV || Opcode == ISD::UDIV) {
        Op  = (Opcode == ISD::SDIV ? Rigel::DIV : Rigel::DIVu);
        MOp = Rigel::MFLO;
      } else {
        Op  = (Opcode == ISD::SREM ? Rigel::DIV : Rigel::DIVu);
        MOp = Rigel::MFHI;
      }
      SDNode *Node = CurDAG->getTargetNode(Op, MVT::Flag, Op1, Op2);

      SDValue InFlag = SDValue(Node, 0);
      return CurDAG->getTargetNode(MOp, MVT::i32, InFlag);
    }
    
    #endif

    // Get target GOT address.
    case ISD::GLOBAL_OFFSET_TABLE: {
      return getGlobalBaseReg();
    }

    /// Handle direct and indirect calls when using PIC. On PIC, when 
    /// GOT is smaller than about 64k, the GA target can be 
    /// loaded with only one instruction. Otherwise GA's target must 
    /// be loaded with 3 instructions. 
    case RigelISD::JmpLink: {
      if (TM.getRelocationModel() == Reloc::PIC_) {
  	    unsigned LastOpNum = Node->getNumOperands()-1;

        SDValue Chain  = Node->getOperand(0);
        SDValue Callee = Node->getOperand(1);
        SDValue InFlag;

        // Skip the incoming flag if present
        if (Node->getOperand(LastOpNum).getValueType() == MVT::Flag)
          LastOpNum--;

        if (isa<GlobalAddressSDNode>(Callee) ||
            isa<ExternalSymbolSDNode>(Callee))
        {
          /// Direct call for global addresses and external symbols
          SDValue GPReg = CurDAG->getRegister(Rigel::GP, MVT::i32);

          // Use load to get GOT target
          SDValue Ops[] = { Callee, GPReg, Chain };
          SDValue Load = SDValue(CurDAG->getMachineNode(Rigel::LW, dl, MVT::i32, 
                                     MVT::Other, Ops, 3), 0);
          Chain = Load.getValue(1);
          //AddToISelQueue(Chain);

          // Call target must be on T5
          Chain = CurDAG->getCopyToReg(Chain, dl, Rigel::T5, Load, InFlag);
        }
        else {
          /// Indirect call
          Chain = CurDAG->getCopyToReg(Chain, dl, Rigel::T5, Callee, InFlag);
        }

        // Map the JmpLink operands to JALR
      	SDVTList NodeTys = CurDAG->getVTList(MVT::Other, MVT::Flag);
      	SmallVector<SDValue, 8> Ops;
      	Ops.push_back(CurDAG->getRegister(Rigel::T5, MVT::i32));

      	for (unsigned i = 2, e = LastOpNum+1; i != e; ++i)
      	  Ops.push_back(Node->getOperand(i));
      	Ops.push_back(Chain);
      	Ops.push_back(Chain.getValue(1));

        // Emit Jump and Link Register
        SDNode *ResNode = CurDAG->getMachineNode(Rigel::JALR, dl, NodeTys,
                                  &Ops[0], Ops.size());
        Chain  = SDValue(ResNode, 0);
        InFlag = SDValue(ResNode, 1);
        ReplaceUses(SDValue(Node, 0), Chain);
        ReplaceUses(SDValue(Node, 1), InFlag);
        return ResNode;
      } //PIC
    } //JmpLink scope
  } //switch(Opcode)

  // Select the default instruction
  return SelectCode(Node);
}

/// createRigelISelDag - This pass converts a legalized DAG into a 
/// Rigel-specific DAG, ready for instruction scheduling.
FunctionPass *llvm::createRigelISelDag(RigelTargetMachine &TM) {
  return new RigelDAGToDAGISel(TM);
}
